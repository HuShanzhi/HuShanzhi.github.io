<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动态时间规整</title>
    <link href="/2025/08/17/%E5%8A%A8%E6%80%81%E6%97%B6%E9%97%B4%E8%A7%84%E6%95%B4/"/>
    <url>/2025/08/17/%E5%8A%A8%E6%80%81%E6%97%B6%E9%97%B4%E8%A7%84%E6%95%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="动态时间规整dtw">动态时间规整（DTW）</h2><h3 id="dtw-算法简介">DTW 算法简介</h3><p><strong>动态时间规整（Dynamic TimeWarping，DTW）</strong>是用于评估两个时间序列相似性的算法，它的核心在计算两个时间序列相似性之前会先进行对齐。</p><p>假设有两个时序序列 <span class="math inline">\(\mathbf{x}=[x_0,x_1,..., x_{n-1}]\)</span>，<span class="math inline">\(\mathbf{y}=[y_0,y_1, ..., y_{m-1}]\)</span>，先假设这两个时间序列是等长的，即 <spanclass="math inline">\(n=m\)</span>。如果要计算它们的相似度，对于欧式距离（欧几里得距离，Euclideandistance）来说，可以表示为</p><p><span class="math display">\[d(\mathbf{x}, \mathbf{y}) = \sqrt{(x_0-y_0)^2 + (x_1-y_2)^2 + \ ... \  +(x_{n-1}-y_{m-1})^n}, \ \ n=m\tag{1}\]</span></p><p>而 DTW 是返回所有的时间对齐路径中最小的欧式距离，可以表示为</p><p><span class="math display">\[DTW(\mathbf{x}, \mathbf{y}) = \min\limits_{\pi \in\mathcal{A}(\mathbf{x}, \mathbf{y})} \sqrt{\sum_{(i,j) \in \pi}{d(x_i,y_j)^2}}\tag{2}\]</span></p><p>其中，<span class="math inline">\(\pi\)</span>表示对齐路径，是一个长度为 <span class="math inline">\(k\)</span>的索引对 <span class="math inline">\(\left( \ (i_0, j_0), \ ... \ ,(i_{k-1}, j_{k-1}) \ \right)\)</span>；<spanclass="math inline">\(\mathcal{A}(\mathbf{x}, \mathbf{y})\)</span>是是所有可接受对齐路径的集合；<span class="math inline">\(d(x_i,y_j)\)</span> 可以表示为 <span class="math inline">\(d(x_i, y_j) =\sqrt{(x_i-y_j)^2} =|x_i-y_j|\)</span>。一条路径若要被视为可接受路径，必须满足以下条件：</p><p>（1）时间序列的开始和结束要匹配在一起，即：</p><p>​ （a）<span class="math inline">\(\pi_0 = (0,0)\)</span></p><p>​ （b）<span class="math inline">\(\pi_{k-1} = (n-1, m-1)\)</span></p><p>（2）在路径中时序序列索引 <span class="math inline">\(i\)</span> 和<span class="math inline">\(j\)</span>应该满足单调递增，且至少出现一次，即：</p><p>​ （a）<span class="math inline">\(i_{q-1} \le i_{q} \le i_{q-1} +1\)</span></p><p>​ （b）<span class="math inline">\(j_{q-1} \le j_{q} \le j_{q-1} +1\)</span></p><p><img src="动态时间规整/欧式距离与动态时间规整的区别-5418387.png" alt="欧式距离与动态时间规整的区别" width="80%"></p><p>图可以明显看出欧氏距离（左）和动态时间规整（DTW，右）来计算两个时间序列之间的相似度的区别。图中灰线表示一个匹配关系或者说是对齐路径中的一个索引对<span class="math inline">\((i,j)\)</span>，所有的灰线就是一个对齐路径<span class="math inline">\(\pi\)</span>（在 DTW 中这个 <spanclass="math inline">\(\pi\)</span>也是最优，即满足最小欧式距离）。当然了左图中欧式距离的匹配关系是固定，始终保证垂直对应（同时刻对应），即满足<span class="math inline">\(i=j\)</span>。</p><h3 id="dtw-的矩阵形式">DTW 的矩阵形式</h3><p>DTW路径可以用二进制矩阵表示，其中非零元素 1表示对应的时间序列元素是匹配的，和上面对齐路径中 <spanclass="math inline">\(\pi\)</span> 的一个索引对 <spanclass="math inline">\((i,j)\)</span> 是等价的。</p><p><span class="math display">\[(A_{\pi})_{i,j} =\begin{cases}1, &amp; if \ (i, j) \in \pi  \\0, &amp; otherwise\end{cases}\tag{3}\]</span></p><p><img src="动态时间规整/动态时间扭曲路径表示为二进制矩阵形式-5418387.png" alt="动态时间扭曲路径表示为二进制矩阵形式" width="80%"></p><p>左图中的灰色线表示一条对齐路径 <spanclass="math inline">\(\pi\)</span>，灰色点表示一个索引对 <spanclass="math inline">\((i,j)\)</span> ，在矩阵 <spanclass="math inline">\(A_{\pi}\)</span> 中灰色点为 1，其余为 0。</p><p>因此，动态时间规整可以写成矩阵之间点积的最小化：</p><p><span class="math display">\[DTW(\mathbf{x}, \mathbf{y}) = \min\limits_{\pi \in\mathcal{A}(\mathbf{x}, \mathbf{y})} \sqrt {&lt;A_{\pi}, D(x,y)&gt;}\tag{4}\]</span></p><p>其中，<span class="math inline">\(D(x,y)\)</span> 存储的为 <spanclass="math inline">\(d(x_i, y_j)^2\)</span>，其与式（2）是等价的。</p><h3 id="算法实现动态规划">算法实现（动态规划）</h3><p>虽然按照顺序找出所有的路径 <spanclass="math inline">\(\mathcal{A}(\mathbf{x}, \mathbf{y})\)</span>后计算最小值是困难的（共有 <spanclass="math inline">\(O(\frac{(3+2\sqrt{2})^2}{\sqrt{n}})\)</span>条路径，文章[1]给出，暂未证明），但幸运的是可以使用动态规划找到该优化问题的精确解。动态规划依赖于递归，即将给定问题的解与（更简单的）子问题的解联系起来。一旦知道了这种联系，动态规划方法就会通过递归求解所需的子问题并存储其解以供后续使用（从而避免多次重复计算子问题）来解决原始问题。其算法复杂度为<span class="math inline">\(O(nm)\)</span>。</p><p>假设有两个时序序列 <span class="math inline">\(\mathbf{x}=[x_1,x_2,..., x_{n}]\)</span>，<span class="math inline">\(\mathbf{y}=[y_1, y_2,..., y_{m}]\)</span>，计算 <span class="math inline">\(DTW(\mathbf{x},\mathbf{y})\)</span> 的伪代码可以表示为：</p><p><img src="动态时间规整/DTW算法伪代码-5418387.png" alt="DTW算法伪代码" width="70%"></p><p>此外，我们还可以找到最优路径 <spanclass="math inline">\(path\)</span>。</p><p><img src="动态时间规整/DTW算法最优规整路径伪代码-5418387.png" alt="DTW算法最优规整路径伪代码" width="70%"></p><h2 id="时间加权动态时间规整twdtw">时间加权动态时间规整（TWDTW）</h2><p><strong>时间加权动态时间规整（Time-Weighted Dynamic Time Warping，TWDTW）</strong>相较于动态时间规整的主要不同在于：动态时间规整计算两个匹配元素<span class="math inline">\((x_i, y_j)\)</span> 的距离为欧式距离，即</p><p><span class="math display">\[d(x_i, y_j) = \sqrt{(x_i-y_j)^2} = |x_i-y_j|\tag{5}\]</span></p><p>而时间加权动态时间规整计算两个匹配元素 <spanclass="math inline">\((x_i, y_j)\)</span> 的距离（惩罚）公式为：</p><p><span class="math display">\[c(x_i, y_j) = \sqrt{(1-\alpha)(i-j)^2+\alpha(x_i-y_j)^2}\tag{6}\]</span></p><h2 id="dtw-的应用">DTW 的应用</h2><p>文章 [2] 提到 DTW被设计用来评估两个时间序列相似性，其开始主要用于语音识别，后被用于许多领域：手写和在线签名匹配、手语识别和手势识别，数据挖掘与时间序列聚类（时间序列数据库检索）、计算机视觉与计算机动画、监视、蛋白质序列比对与化学工程、音乐和信号处理。但这里我们主要是介绍DTW 的变形—时间加权动态时间规整在寻找两个时间序列的时滞关系的应用。</p><h3 id="寻找两个时间序列的时滞关系">寻找两个时间序列的时滞关系</h3><p>假设有两个温度测点，分别位于蒸汽加热器管道入口处和出口处，我们采集它们的一段历史趋势可以构成两个时间序列<span class="math inline">\(T_1\)</span> 和 <spanclass="math inline">\(T_2\)</span>。为了方便阐述和简化计算，我们将采样间隔定位2 分钟，采集了这两个测点 1 个小时的数据，如下图所示：</p><p><img src="动态时间规整/蒸汽加热器管道入口出口测点温度趋势图-5418387.png" alt="蒸汽加热器管道入口出口测点温度趋势图" width="90%"></p><p>利用 TWDTW算法 我们可以获取它们的匹配关系。</p><p><img src="动态时间规整/最优扭曲路径-5418387.png" alt="最优扭曲路径" width="80%"></p><p><img src="动态时间规整/蒸汽加热器管道入口出口测点时滞关系-5418387.png" alt="蒸汽加热器管道入口出口测点时滞关系" width="90%"></p><h2 id="参考">参考</h2><p>[1] Romain Tavenard. An introduction to Dynamic Time Warping[EB/OL].2021.<ahref="https://rtavenar.github.io/blog/dtw.html">https://rtavenar.github.io/blog/dtw.html</a>.</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex">@misc&#123;tavenard.blog.dtw,<br>  author=&quot;Romain Tavenard&quot;,<br>  title=&quot;An introduction to Dynamic Time Warping&quot;,<br>  year=2021,<br>  howpublished=&quot;<span class="hljs-keyword">\url</span>&#123;<span class="hljs-link">https://rtavenar.github.io/blog/dtw.html</span>&#125;&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>[2] Senin, Pavel. Dynamic Time Warping Algorithm Review[R]. Honolulu,HI, USA, 2008.</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs latex">@techreport&#123;senin2008dtwReview,<br>  author      = &#123;Senin, Pavel&#125;,<br>  title       = &#123;Dynamic Time Warping Algorithm Review&#125;,<br>  institution = &#123;Department of Information and Computer Sciences, University of Hawaii at Manoa&#125;,<br>  number      = &#123;CSDL-08-04&#125;,<br>  address     = &#123;Honolulu, HI, USA&#125;,<br>  month       = dec,<br>  year        = &#123;2008&#125;,<br>  note        = &#123;[R]&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="附件">附件</h2><ol type="1"><li>文章中伪代码的 latex 代码</li></ol><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[a4paper,11pt]&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;algorithm&#125; <br><span class="hljs-keyword">\usepackage</span>&#123;algpseudocode&#125; <br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">% Algorithm 1: Dynamic Time Warping</span><br><span class="hljs-keyword">\begin</span>&#123;algorithm&#125;<br><span class="hljs-keyword">\caption</span>&#123;Dynamic Time Warping (DTW)&#125;<br><span class="hljs-keyword">\begin</span>&#123;algorithmic&#125;[1]<br>            <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>n <span class="hljs-keyword">\leftarrow</span> |<span class="hljs-keyword">\mathbf</span>&#123;x&#125;|<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>m <span class="hljs-keyword">\leftarrow</span> |<span class="hljs-keyword">\mathbf</span>&#123;y&#125;|<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>dtw[] <span class="hljs-keyword">\leftarrow</span> new <span class="hljs-keyword">\ </span>[n <span class="hljs-keyword">\times</span> m]<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>dtw(0,0) <span class="hljs-keyword">\leftarrow</span> 0<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\For</span> &#123;<span class="hljs-built_in">$</span>i=1,2,<span class="hljs-keyword">\ldots</span>,n<span class="hljs-built_in">$</span>&#125;<br>                <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>dtw(i, 1) <span class="hljs-keyword">\leftarrow</span> dtw(i-1, 1) + d(x<span class="hljs-built_in">_</span>i, y<span class="hljs-built_in">_</span>1)<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\EndFor</span><br>            <span class="hljs-keyword">\For</span> &#123;<span class="hljs-built_in">$</span>j=1,2,<span class="hljs-keyword">\ldots</span>,m<span class="hljs-built_in">$</span>&#125;<br>                <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>dtw(1, j) <span class="hljs-keyword">\leftarrow</span> dtw(1, j-1) + d(x<span class="hljs-built_in">_</span>1, y<span class="hljs-built_in">_</span>i)<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\EndFor</span><br>            <span class="hljs-keyword">\For</span> &#123;<span class="hljs-built_in">$</span>i=1,2,<span class="hljs-keyword">\ldots</span>,n<span class="hljs-built_in">$</span>&#125;<br>                <span class="hljs-keyword">\For</span> &#123;<span class="hljs-built_in">$</span>j=1,2,<span class="hljs-keyword">\ldots</span>,m<span class="hljs-built_in">$</span>&#125;<br>                    <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>dtw(i, j) <span class="hljs-keyword">\leftarrow</span> d(x<span class="hljs-built_in">_</span>i, y<span class="hljs-built_in">_</span>j) + min&#123;(dtw(i-1, j), dtw(i, j-1), dtw(i-1, j-1))&#125;<span class="hljs-built_in">$</span><br>                <span class="hljs-keyword">\EndFor</span><br>            <span class="hljs-keyword">\EndFor</span><br>            <span class="hljs-keyword">\State</span> return <span class="hljs-built_in">$</span>dtw<span class="hljs-built_in">$</span><br><span class="hljs-keyword">\end</span>&#123;algorithmic&#125; <br><span class="hljs-keyword">\end</span>&#123;algorithm&#125;<br><br><span class="hljs-comment">% Algorithm 2 Optimal Warping Path</span><br><span class="hljs-keyword">\begin</span>&#123;algorithm&#125;<br><span class="hljs-keyword">\caption</span>&#123;Optimal Warping Path (DTW)&#125;<br><span class="hljs-keyword">\begin</span>&#123;algorithmic&#125;[1]<br>            <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>path[] <span class="hljs-keyword">\leftarrow</span> new <span class="hljs-keyword">\ </span>array<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>i <span class="hljs-keyword">\leftarrow</span> rows(dtw)<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>j <span class="hljs-keyword">\leftarrow</span> columns(dtw)<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\While</span>&#123;<span class="hljs-built_in">$</span>(i&gt;1) <span class="hljs-keyword">\&amp;</span> (j&gt;1)<span class="hljs-built_in">$</span>&#125;<br>                <span class="hljs-keyword">\If</span> &#123;<span class="hljs-built_in">$</span>i==1<span class="hljs-built_in">$</span>&#125;<br>                    <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>j=j-1<span class="hljs-built_in">$</span><br>                <span class="hljs-keyword">\ElsIf</span> &#123;<span class="hljs-built_in">$</span>j==1<span class="hljs-built_in">$</span>&#125;<br>                    <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>i=i-1<span class="hljs-built_in">$</span><br>                <span class="hljs-keyword">\Else</span><br>                    <span class="hljs-keyword">\If</span> &#123;<span class="hljs-built_in">$</span>dtw(i-1, j) == min&#123;(dtw(i-1, j), dtw(i, j-1), dtw(i-1, j-1))&#125;<span class="hljs-built_in">$</span>&#125;<br>                        <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>i=i-1<span class="hljs-built_in">$</span><br>                    <span class="hljs-keyword">\ElsIf</span> &#123;<span class="hljs-built_in">$</span>dtw(i, j-1) == min&#123;(dtw(i-1, j), dtw(i, j-1), dtw(i-1, j-1))&#125;<span class="hljs-built_in">$</span>&#125;<br>                        <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>j=j-1<span class="hljs-built_in">$</span><br>                    <span class="hljs-keyword">\Else</span><br>                        <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>i=i-1<span class="hljs-built_in">$</span><br>                        <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>j=j-1<span class="hljs-built_in">$</span><br>                    <span class="hljs-keyword">\EndIf</span><br>                    <span class="hljs-keyword">\State</span> path.add((i,j))<br>                <span class="hljs-keyword">\EndIf</span><br>            <span class="hljs-keyword">\EndWhile</span><br>            <span class="hljs-keyword">\State</span> return <span class="hljs-built_in">$</span>path<span class="hljs-built_in">$</span><br><span class="hljs-keyword">\end</span>&#123;algorithmic&#125; <br><span class="hljs-keyword">\end</span>&#123;algorithm&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pid控制器</title>
    <link href="/2025/08/17/pid%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <url>/2025/08/17/pid%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="反馈回路">反馈回路</h2><p><img src="PID控制器/反馈控制系统.png" alt="反馈控制系统" width="80%"></p><p>这是一个典型的反馈控制系统，其中：</p><table><thead><tr class="header"><th></th><th>含义</th><th>英文</th><th>举例（以一级喷水减温控制系统为例）</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(SP\)</span></td><td>设定值</td><td>Set Point</td><td>一级过热汽温设定值（一般由运行手操）</td></tr><tr class="even"><td><span class="math inline">\(PV\)</span></td><td>过程变量</td><td>Process Value</td><td>一级过热汽温测量值（测点一般选二级减温器前温度）</td></tr><tr class="odd"><td><span class="math inline">\(OP\)</span></td><td>控制器输出</td><td>Output</td><td>一级减温水阀门开度</td></tr><tr class="even"><td><span class="math inline">\(e(t)\)</span></td><td>偏差</td><td></td><td><span class="math inline">\(PV-SP\)</span></td></tr><tr class="odd"><td><span class="math inline">\(u(t)\)</span></td><td>被控对象输入</td><td></td><td>一级减温水流量</td></tr><tr class="even"><td><span class="math inline">\(y(t)\)</span></td><td>被控对象输出</td><td></td><td>一级过热汽温</td></tr><tr class="odd"><td><span class="math inline">\(d(t)\)</span></td><td>扰动</td><td></td><td>煤质、入炉煤含水率、炉膛吸热分布</td></tr></tbody></table><p>为了叙述方便，后文中 <span class="math inline">\(OP\)</span> 和 <spanclass="math inline">\(u(t)\)</span> 、<spanclass="math inline">\(PV\)</span> 和 <spanclass="math inline">\(y(t)\)</span> 是等价的。</p><h2 id="pid分类">PID分类</h2><p>PID有很多分类方式：可以根据时间域特性/实现方式分为<strong>连续型</strong>和<strong>离散型</strong>；可以根据控制器输出形式（控制量本身或者控制量的增量）来分为<strong>位置式</strong>和<strong>增量式</strong>；可以根据结构形式分为<strong>串联形式PID（交互式）</strong>、<strong>并联形式PID</strong>和<strong>标准形式PID（非交互式、ISA形式、理想形式）</strong>。</p><h3 id="连续型和离散型pid">连续型和离散型PID</h3><p>（1）连续型 <span class="math display">\[u(t) = K_P e(t) + K_I \int_0^te(t)dt + K_D \frac{de(t)}{dt}\]</span> （2）离散型 <span class="math display">\[u_k = K_Pe_k + K_I \sum_{j=0}^{k}e_j \cdot T + K_D \cdot\frac{e_k-e_{k-1}}{T}\]</span> 其中 <span class="math inline">\(T\)</span> 为采样时间。</p><h3 id="位置式和增量式pid">位置式和增量式PID</h3><p>（1）位置式 <span class="math display">\[u_k = K_Pe_k + K_I \sum_{j=0}^{k}e_j \cdot T + K_D \cdot\frac{e_k-e_{k-1}}{T}\]</span> 其中 <span class="math inline">\(T\)</span> 为采样时间。</p><p>（2）增量式 <span class="math display">\[\Delta{u_k} = K_P(e_k - e_{k-1}) + K_I e_k \cdot T + K_D \cdot\frac{e_k-2e_{k-1}+e_{k-2}}{T}\\u_k = u_{k-1} + \Delta{u_k}\]</span></p><p>（3）证明位置式与增量式等价</p><blockquote><p>【证明 1】： <span class="math display">\[\begin{aligned}\Delta{u_k} &amp;= u_k - u_{k-1} \\&amp;= K_Pe_k + K_I \sum_{j=0}^{k}e_j \cdot T + K_D \cdot\frac{e_k-e_{k-1}}{T} - (K_Pe_{k-1} + K_I \sum_{j=0}^{k-1}e_j \cdot T  +K_D \cdot \frac{e_{k-1}-e_{k-2}}{T}) \\&amp;= K_P(e_k - e_{k-1}) + K_I e_k \cdot T + K_D \cdot\frac{e_k-2e_{k-1}+e_{k-2}}{T}\end{aligned}\]</span></p></blockquote><blockquote><p>【证明 2】： <span class="math display">\[\begin{aligned}u_k &amp;= u_{k-1} + \Delta{u_k} \\&amp;= u_0 + \Delta{u_1} + \Delta{u_2} + ... + \Delta{u_k} \\&amp;= u_0 + K_p(e_k - e_0) + K_I \sum_{j=1}^{k}e_j \cdot T + K_D\frac{e_k-e_{k-1}-e_0+e_{-1}}{T}\end{aligned}\]</span></p></blockquote><h3 id="串行并行和标准型pid">串行、并行和标准型PID</h3><p>（1）串联形式PID</p><p><img src="PID控制器/串行PID结构图.png" alt="串行PID结构图" width="80%"><span class="math display">\[u(t) = K_P \left[ \left( 1 + \frac{T_D}{T_I} \right) e(t) +\frac{1}{T_I} \int_0^t e(t) dt + T_D \frac{de(t)}{dt} \right]\]</span></p><p>（2）并联形式PID</p><p><img src="PID控制器/并行PID结构图.png" alt="并行PID结构图" width="80%"><span class="math display">\[u(t) = K_P e(t) + K_I \int_0^te(t)dt + K_D \frac{de(t)}{dt}\]</span> 并行结构允许比例、积分和微分作用完全解耦，即 PID的三个参数都相互独立。</p><p>（3）标准形式PID</p><p><img src="PID控制器/理想型PID结构图.png" alt="理想型PID结构图" width="80%"><span class="math display">\[\begin{align}u(t) &amp;= K_P \left[ e(t) + \frac{1}{T_I} \int_0^te(t)dt + T_D\frac{de(t)}{dt}\right] \\&amp;= K_P e(t) + \frac{K_P}{T_I} \int_0^te(t)dt + K_P T_D\frac{de(t)}{dt}\end{align}\]</span> 标准型结构中，修改 <span class="math inline">\(K_P\)</span>系数将影响比例、积分和微分作用。相较于并行结构，标准型的各参数有其明确的物理意义：</p><table><thead><tr class="header"><th></th><th><span class="math inline">\(K_P\)</span></th><th><span class="math inline">\(T_I\)</span></th><th><span class="math inline">\(T_D\)</span></th></tr></thead><tbody><tr class="odd"><td>名称</td><td>比例增益（Proportional Gain）</td><td>积分时间常数（Integral Time）</td><td>微分时间常数（Derivative Time）</td></tr><tr class="even"><td>物理意义</td><td>（1）决定当前误差 e(t) 对控制输出的影响强度;<br />（2）增大 <spanclass="math inline">\(K_P\)</span>，系统响应更快，纠正动作更激烈，但容易振荡；<br />（3）减小<spanclass="math inline">\(K_P\)</span>，系统响应变慢，稳态误差可能增大。</td><td>（1）积分项的时间基准，决定过去误差累积对控制输出的影响；<br />（2）积分项希望在误差持续存在的情况下不断“积累”，逐步将误差逼近0；<br />（3）积分作用越强（即<spanclass="math inline">\(T_I\)</span>越小），系统越快尝试消除稳态误差。</td><td>（1）预测未来误差趋势；<br />（2）用误差的变化率来提前做出反应；<br />（3）增大<spanclass="math inline">\(T_D\)</span>，系统会更敏感地对误差的变化速度做出反应（如防止超调），但太大容易放大噪声，系统变得不稳定。</td></tr><tr class="odd"><td>通俗理解</td><td><span class="math inline">\(K_P\)</span>决定了当前误差的重要性。</td><td>在理想条件下，如果误差维持不变，系统将在 <spanclass="math inline">\(T_I\)</span> 秒后将该误差完全消除。</td><td>预测如果当前误差增长趋势持续 <spanclass="math inline">\(T_D\)</span> 秒，将会出现多大误差，提前修正。</td></tr></tbody></table><blockquote><p><strong>解释一下为什么”在理想条件下，如果误差维持不变，系统将在 <spanclass="math inline">\(T_I\)</span> 秒后将该误差完全消除“？</strong></p><p>假设控制误差 <span class="math inline">\(e(t) = e_0\)</span>是一个不变的常数（比如由于一个阶跃扰动导致系统输出偏离设定值），初始控制器输出为0，被控对象是时不变系统（即在不同时间，对系统施加相同的 <spanclass="math inline">\(u(t)\)</span> ，系统输出 <spanclass="math inline">\(y(t)\)</span>不变），不考虑微分项，所以控制器的输出可以表示为： <spanclass="math display">\[\begin{align}u(t) &amp;= K_P \left[ e_0 + \frac{1}{T_I} \int_0^t e_0 dt \right] \\&amp;= K_P \left[ e_0 + \frac{1}{T_I} e_0 t \right] \\&amp;= K_P e_0 \left[ 1 + \frac{t}{T_I} \right]\end{align}\]</span> 由于 <span class="math inline">\(e_0\)</span> 是常数，所以<span class="math inline">\(u(t)\)</span>中比例部分是不变的（这也是为什么纯比例调节无法消除静态误差，因为对于时不变系统来时，施加相同的<span class="math inline">\(u(t)\)</span> ，系统输出 <spanclass="math inline">\(y(t)\)</span> 是不变，如果 <spanclass="math inline">\(u(t)\)</span> 那 <spanclass="math inline">\(y(t)\)</span>也不会变化，所以误差一直存在，即静态误差，或叫稳态误差），只有积分部分才影响<span class="math inline">\(u(t)\)</span> ，或者可以求一下上式的微分：<span class="math display">\[\frac{du(t)}{dt} = \frac{K_P}{T_I} \cdot e_0\]</span> 更加明显地看出只有积分部分才影响 <spanclass="math inline">\(u(t)\)</span>的变化，且是线性增加的（每个周期都增加 <spanclass="math inline">\(\frac{K_P}{T_I} \cdot e_0\)</span>），<spanclass="math inline">\(u(t)\)</span> 的变化会推动 <spanclass="math inline">\(y(t)\)</span> 靠近设定值，最终消除偏差。</p><p>先假设 <span class="math inline">\(\Delta y(t) = \frac{1}{K_P} \cdot\Delta u(t)\)</span>， 即当 <span class="math inline">\(u(t)\)</span>变化 <span class="math inline">\(\Delta u(t)\)</span> 时，<spanclass="math inline">\(y(t)\)</span> 就变化 <spanclass="math inline">\(\frac{1}{K_P} \cdot \Deltau(t)\)</span>（这里涉及了如何确定一个纯比例控制器的 <spanclass="math inline">\(K_P\)</span>值，后面讲调节方法的时候会再提及），那么如果想要消除误差 <spanclass="math inline">\(e_0\)</span>，就应该让 <spanclass="math inline">\(u(t)\)</span> 变化 <span class="math inline">\(K_Pe_0\)</span>，即 <span class="math inline">\(u(t+T) = u(t) + K_Pe_0\)</span>，前面已经说明了比例作用是不会让 <spanclass="math inline">\(u(t)\)</span> 变化的，所以其中 <spanclass="math inline">\(T\)</span> 就表明了积分作用需要 <spanclass="math inline">\(T\)</span> 时刻让 <spanclass="math inline">\(u(t)\)</span> 变化 <spanclass="math inline">\(e_0\)</span>，故现在只需要证明 <spanclass="math inline">\(T_I = T\)</span> 即可，证明如下： <spanclass="math display">\[\begin{align}&amp; u(t + T) - u(t) = K_P e_0 \\&amp;\implies K_P e_0 \left[ 1 + \frac{t+T}{T_I} \right] - K_P e_0\left[ 1 + \frac{t}{T_I} \right] = K_P e_0 \\&amp;\implies K_P e_0 \frac{T}{T_I} = K_P e_0 \\&amp;\implies T = T_I\end{align}\]</span></p><p>说明了系统将在 <span class="math inline">\(T_I\)</span> 秒后将误差<span class="math inline">\(e_0\)</span> 彻底消除，积分项在 <spanclass="math inline">\(T_I\)</span> 秒内就能产生与比例项相等的作用。</p></blockquote><h2 id="pid整定">PID整定</h2><h3id="pid控制器不同参数的阶跃响应分析">PID控制器不同参数的阶跃响应分析</h3><p><img src="PID控制器/PI控制器效果示意图.png" alt="PI控制器效果示意图" width="90%"></p><p>上图显示了比例系数<spanclass="math inline">\(K_P\)</span>和积分时间<spanclass="math inline">\(T_I\)</span>的差异如何影响 PI控制器的响应。正中间的图形为基本情况，随着参数的整定，无论是翻倍还是减半，过程的每一个动态响应都截然不同。左上角的图显示，当比例作用加倍（比例系数加倍）且积分作用加倍（积分时间减半）时，控制器会产生大而缓慢的阻尼振荡。相反，右下角的图显示，当控制器比例作用减半（比例系数减半）且积分作用减半（积分时间加倍）时，响应变慢。</p><blockquote><p>比例作用和积分作用增强时，系统振荡；比例作用和积分作用减弱时，系统响应变慢。</p></blockquote><p><img src="PID控制器/纯比例控制比例增益不同时的设定中阶跃响应曲线.png" alt="纯比例控制比例增益不同时的设定中阶跃响应曲线" width="80%"></p><p>比例系数 <span class="math inline">\(K_P\)</span>加大，使系统的动作灵敏，速度加快，振荡次数增多，调节时间变长。当比例系数太大时，系统会趋于不稳定。加大比例系数，在系统稳定的情况下，可以减小余差，提高控制精度，却不能完全消除余差（有余差，系统始终未达到1）。</p><p><img src="PID控制器/纯比例控制和比例积分控制阶跃响应曲线.png" alt="纯比例控制和比例积分控制阶跃响应曲线" width="80%"></p><p>PI 控制器主要用来改善控制系统的稳态性能。因为单纯增大 P的方法减小余差的同时会使系统的超调量增大，破坏了系统的平稳性，而积分环节的引入可以与P 控制合作来消除上述的副作用。此外，引入积分作用可以消除余差。</p><p><img src="PID控制器/PID控制阶跃响应曲线.png" alt="PID控制阶跃响应曲线" width="80%"></p><p>增加微分有利于加快系统的响应速度，使系统的超调量减小，稳定性增加，同时增大比例可以进一步加快系统的响应速度，使系统更快速。</p><h3 id="自衡对象和积分对象">自衡对象和积分对象</h3><p>工业过程中常见的过程有自衡和非自衡两种，下图显示了两个过程对输出阶跃变化的理想化趋势。左边的过程是非积分对象，也叫自衡对象；右边的过程是非自衡对象，也叫积分对象。如下图左侧所示，自衡对象能够响应控制器输出并逐渐达到新的稳态操作点，典型的自衡对象如调节阀控制的流量；如右侧所示，积分过程没有平衡点，即控制器输出变化后过程在一个方向持续变化，除非进行新的干预否则积分过程将持续变化而无法达到新的稳态，典型的积分对象如液位。</p><p><img src="PID控制器/自衡对象和积分对象.png" alt="自衡对象和积分对象" width="100%"></p><h3 id="pid控制器正反作用判定">PID控制器正反作用判定</h3><p><img src="PID控制器/PID控制器.png" alt="PID控制器" width="20%"></p><table><thead><tr class="header"><th></th><th>正作用</th><th>反作用</th></tr></thead><tbody><tr class="odd"><td>偏差计算</td><td><span class="math inline">\(e = PV-SP\)</span></td><td><span class="math inline">\(e = SP-PV\)</span></td></tr><tr class="even"><td><span class="math inline">\(PV\)</span>与<spanclass="math inline">\(OP\)</span>的关系</td><td><span class="math inline">\(PV\)</span>与<spanclass="math inline">\(OP\)</span>同向（<span class="math inline">\(PV\nearrow\)</span>，<span class="math inline">\(OP \nearrow\)</span>）</td><td><span class="math inline">\(PV\)</span>与<spanclass="math inline">\(OP\)</span>反向（<span class="math inline">\(PV\nearrow\)</span>，<span class="math inline">\(OP \searrow\)</span>）</td></tr><tr class="odd"><td>控制系统</td><td>反过程</td><td>正过程</td></tr></tbody></table><p>判定PID控制器应该采用正作用还是反作用的方法：</p><p>（1）先判定被控对象是正过程还是反过程</p><p>根据控制量与被控量直接的物理因果关系来判断，当控制量增大，被控量也增大时，为正过程；当控制量增大，被控量减小时，为反过程。火电中常见的正过程有：汽机阀门控制（汽机阀门开度增大，蒸汽流量增大）；反过程有：减温水控制（喷水减温阀门开度增大，蒸汽温度减小）。</p><p>（2）根据被控对象选择正反作用</p><p>如果被控对象是反过程则控制器应选择正作用，如果是正过程则选择反作用。</p><h3 id="关于pid的调试技巧">关于PID的调试技巧</h3><blockquote><p>PID的整定方法有很多，这里只是整理一下自己的调试思路。</p></blockquote><p>（1）研究被控对象，确定其是正过程还是反过程，然后确定PID控制器应该采用反作用（正过程）还是正作用（反过程）</p><p>这里以一级过热蒸汽喷水减温控制系统为例：（实际上它的控制系统是一个串级PID，这里为了方便叙述我们简化了，调试的方法的都是类似，只不过串级PID需要先将内环PID先整定好，使得它内环的PV值可以很快的去跟随SP值（外环的输出OP）。）</p><p><img src="PID控制器/一级过热蒸汽喷水减温控制系统.png" alt="一级过热蒸汽喷水减温控制系统" width="60%"></p><p>首先确定我们的目的是通过控制减温水阀门的开度来控制喷水减温的流量，最终将屏式过热器后的蒸汽温度控制在设定值的附近。阀门开度（控制量）增加，蒸汽温度（被控量）减小，所以该被控对象为反过程，PID控制器应该选择正作用。PID控制器的SP为屏式过热器后汽温设定值，PV为屏式过热器后汽温测量值，OP为减温水阀门开度。</p><p>（2）确定纯比例调节的<span class="math inline">\(K_P\)</span>数值</p><blockquote><p>这里提到的 <span class="math inline">\(OP\)</span> 和 <spanclass="math inline">\(u(t)\)</span> 、<spanclass="math inline">\(PV\)</span> 和 <spanclass="math inline">\(y(t)\)</span> 是等价的。</p></blockquote><p>纯比例控制： <span class="math display">\[u(t) = K_P \cdot e(t)\]</span>这里首先需要确定单位OP动作可以影响多少PV，假设PV和OP是存在线性关系的，即</p><p><span class="math display">\[y(t) = K \cdot u(t) + b\]</span></p><p>可以采集历史数据后，进行线性回归获得这个 <spanclass="math inline">\(K\)</span>值，它也被叫做过程模型的增益，或者表示为</p><p><span class="math display">\[K = \frac{\Delta PV}{\Delta OP}\]</span></p><p>此时便确定了单位OP动作可以影响多少PV，即OP每变化单位1，PV会改变单位<spanclass="math inline">\(K\)</span>。所以当PV与SP的偏差为单位1的时候，OP就需要动作<span class="math inline">\(\frac{1}{K}\)</span>，所以这个 <spanclass="math inline">\(\frac{1}{K}\)</span>的绝对值就是纯比例调节应该设置的 <spanclass="math inline">\(K_P\)</span> 值，即： <spanclass="math display">\[K_P = \vert \frac{1}{K} \vert\]</span></p><blockquote><p><strong>解释一下为什么 “<spanclass="math inline">\(\frac{1}{K}\)</span>的绝对值就是纯比例调节应该设置的 <spanclass="math inline">\(K_P\)</span> 值”？</strong></p><p>刚才已经确定了OP每变化单位1，PV会改变单位 <spanclass="math inline">\(K\)</span>，即 <span class="math display">\[\Delta y(t) = K \cdot \Delta u(t)\]</span> 假设 <span class="math inline">\(t\)</span>时刻因阶跃扰动产生了一个控制误差 <span class="math inline">\(e(t) =e_0\)</span>，对于纯比例控制，如果想消除这个偏差 <spanclass="math inline">\(e_0\)</span>，需要让 <spanclass="math inline">\(y(t)\)</span> 改变 <spanclass="math inline">\(e_0\)</span>，那么 <spanclass="math inline">\(\Delta u(t)\)</span> 应该满足 <spanclass="math inline">\(\Delta u(t) = \frac{1}{K} e_0\)</span>，怎么让<span class="math inline">\(\Delta u(t) = \frac{1}{K} e_0\)</span>呢？根据纯比例控制的PID公式可知： <span class="math display">\[\begin{align}&amp; u(t) = K_P \cdot e(t) \\&amp; \implies u(t) - u(t-1) = K_P \cdot \left[ e(t) - e(t-1) \right] \\&amp; \implies \Delta u(t) = K_P \cdot \left[ e_0 - 0 \right] \\&amp; \implies \Delta u(t) = K_P e_0 \\\end{align}\]</span></p><p>当 <span class="math inline">\(K_P = \frac{1}{K}\)</span> 时，<spanclass="math inline">\(\Delta u(t) = \frac{1}{K}e_0\)</span>，但如果系统时反过程，那么 <span class="math inline">\(K&lt; 0\)</span>， 所以 <span class="math inline">\(K_P\)</span> 设为<span class="math inline">\(\frac{1}{K}\)</span> 的绝对值，即<spanclass="math inline">\(K_P = \vert \frac{1}{K} \vert\)</span>。</p></blockquote><p><strong>注意在拟合模型增益 <span class="math inline">\(K\)</span>的时候，要消除系统滞后带来的影响，即拟合：</strong> <spanclass="math display">\[y(t+\tau) = K \cdot u(t) + b\]</span><img src="PID控制器/拟合过程模型的增益.png" alt="拟合过程模型的增益" width="90%"></p><p>如图所示，可以找到一些关联数据段<span class="math inline">\(( \ u(t),\ y(t+\tau) \ )\)</span>，拟合出不同时间段（不同工况下）的模型增益 <spanclass="math inline">\(K\)</span>，然后可以利用核密度估计等方法找到它们的中心点作为模型增益 <spanclass="math inline">\(K\)</span> ，进而计算出纯比例控制下的 <spanclass="math inline">\(K_P\)</span> 值。</p><p>（3）将计算得的纯比例调节下的 <spanclass="math inline">\(K_P\)</span> 值和一个较大的<spanclass="math inline">\(T_I\)</span>值（比如 <spanclass="math inline">\(T_I = 1000s\)</span>）设入PID控制器，然后逐渐减小<span class="math inline">\(K_P\)</span>（减小比例作用） 和 <spanclass="math inline">\(T_I\)</span> （增加积分作用）。</p><h2 id="参考">参考</h2><p>[1] 冯少辉. PID 参数整定与复杂控制[M]. 北京: 化学工业出版社,2023(11).</p><h2 id="附件">附件</h2><p>【代码1】<ahref="https://github.com/HuShanzhi/pid_controller_demo/blob/main/pid_simulator_dash.py">基于dash的PID控制仿真器</a></p><p>【代码2】<ahref="https://github.com/HuShanzhi/pid_controller_demo/blob/main/pid_anlysis.ipynb">PID控制器不同参数的阶跃响应分析</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟模型控制</title>
    <link href="/2023/05/07/%E8%99%9A%E6%8B%9F%E6%A8%A1%E5%9E%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/05/07/%E8%99%9A%E6%8B%9F%E6%A8%A1%E5%9E%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是vmc">1 什么是VMC</h2><p>VMC是一种直觉控制方式，其核心思想是利用假想的虚拟构件(如弹簧、阻尼器、轴承等等)连接机器人内部作用点，或者连接作用点与外部环境，产生相应的虚拟力来“驱使”机器人实现期望的运动。这些虚拟力通过Jacobian矩阵计算得到期望的关节力矩，作为关节控制的输入，驱动机器人运动以产生和虚拟构件一样的作用效果。<strong>VMC的应用关键在于两点：一是在每个需要控制的自由度上构造恰当的虚拟构件以产生合适的虚拟力；二是在不同的相位状态利用相应的Jacobian 矩阵计算期望的关节力矩。</strong></p><h3 id="雅可比矩阵">1.1 雅可比矩阵</h3><p>虚拟力不是实际存在的作用力或力矩，机器人的运动最终是通过关节力矩实现的。为了将工作空间(TaskSpace)的力或力矩映射成关节空间(JointSpace)的关节力矩，需要先求得这两个空间的位置映射关系，即正运动学模型：<span class="math display">\[\pmb{x} = f(\pmb{q}) \tag{1}\]</span> 其中，<span class="math inline">\(\pmb{x} = [x_1\ x_2 \ ...x_m]^T\)</span> 为机体坐标系相对于地面坐标系的<spanclass="math inline">\(m\)</span>个自由度对应的位姿向量，<spanclass="math inline">\(\pmb{q} = [q_1 \ q_2 \ ... q_n]^T\)</span> 为<spanclass="math inline">\(n\)</span>个关节变量的位置向量。对式 （1），分别求<span class="math inline">\(\pmb{x}\)</span> 对 <spanclass="math inline">\(\pmb{q}\)</span> 的偏导数得： <spanclass="math display">\[\begin{cases}\delta x_1 = \frac{\partial f1}{\partial q_1} \delta q1 + \ ... +\frac{\partial f1}{\partial q_n} \delta qn \\\vdots \\\delta x_m = \frac{\partial fm}{\partial q_1} \delta q1 + \ ... +\frac{\partial fm}{\partial q_n} \delta qn\\\end{cases}\tag{2}\]</span> 即 <span class="math display">\[\delta \pmb{x} =  \begin{bmatrix}\frac{\partial f1}{\partial q_1}&amp;...&amp;\frac{\partial f1}{\partialq_n} \\\vdots&amp;\ddots&amp;\vdots\\\frac{\partial fm}{\partial q_1}&amp;...&amp;\frac{\partial fm}{\partialq_n} \\\end{bmatrix}\delta \pmb{q}\tag{3}\]</span> 可简写为 <span class="math display">\[\delta \pmb{x}_{(m,1)} = \pmb{J}_{(m,n)} \cdot \delta \pmb{q}_{(n,1)}\tag{4}\]</span> <span class="math inline">\(\pmb{J}_{(m,n)}\)</span>即为雅可比矩阵，它可以将关节速度 <spanclass="math inline">\(\dot{q}\)</span> 映射成机体位姿速度 <spanclass="math inline">\(\dot{x}\)</span>。</p><h3 id="外部作用力和关节力矩的关系">1.2 外部作用力和关节力矩的关系</h3><blockquote><p>虚功原理：</p></blockquote><p>根据虚功原理，可得： <span class="math display">\[\pmb{\tau}^T \delta \pmb{q} + (-\pmb{F})^T\delta \pmb{x} = 0\tag{5}\]</span></p><p>其中，<span class="math inline">\(\pmb{\tau} = [\tau_1\ \tau_2 \ ...\tau_n]^T\)</span> 为关节力矩列向量，<spanclass="math inline">\(\pmb{F}=[F_1 \ F_2 \ ... F_m]^T\)</span>为外部作用力。根据式（4）、（5）可得外部作用力和关节力矩之间的关系为：</p><p><span class="math display">\[\pmb{\tau} = \pmb{J}^T \pmb{F}\tag{6}\]</span></p><p>其中，<span class="math inline">\(\pmb{J}\)</span> 为雅可比矩阵。</p><h2 id="示例">2 示例</h2><h3 id="三自由度机械手臂腿利用-vmc-进行追点">2.1三自由度机械手臂（腿）利用 VMC 进行追点</h3><h4 id="机器人环境">2.1.1 机器人环境</h4><p>采用<code>nyu_finger</code>机器人，该机器人来自于项目<ahref="https://github.com/open-dynamic-robot-initiative/nyu_finger">ODRI/ nyu_finger</a>。可以将<code>nyu_finger</code>简化为为一个三自由度机械臂模型，如下所示：</p><figure><img src="/img/虚拟模型控制/三自由度机械臂简化模型.png"alt="图1 三自由度机械臂简化模型" /><figcaption aria-hidden="true">图1 三自由度机械臂简化模型</figcaption></figure><h4 id="正运动学">2.1.2 正运动学</h4><p>首先要求解三自由度机械手臂的正运动学公式，方法如下：</p><ul><li>采用 MDH 法（又称克雷格法）建立坐标系（【注】原论文采用的是 DH法），如下所示：</li></ul><figure><img src="/img/虚拟模型控制/MDH法建立坐标系.png"alt="图2 MDH法建立坐标系" /><figcaption aria-hidden="true">图2 MDH法建立坐标系</figcaption></figure><ul><li><p>建立机器人的连杆参数表；</p><table><thead><tr class="header"><th><span class="math inline">\(i\)</span></th><th><span class="math inline">\(\alpha_{i-1}\)</span></th><th><span class="math inline">\(a_{i-1}\)</span></th><th><span class="math inline">\(d_i\)</span></th><th><span class="math inline">\(\theta_{i}\)</span></th></tr></thead><tbody><tr class="odd"><td>1</td><td>0</td><td>0</td><td>0</td><td><span class="math inline">\(\theta_1\)</span></td></tr><tr class="even"><td>2</td><td><span class="math inline">\(-\pi/2\)</span></td><td>0</td><td><span class="math inline">\(D_2\)</span></td><td><span class="math inline">\(\theta_2\)</span></td></tr><tr class="odd"><td>3</td><td>0</td><td><span class="math inline">\(L_2\)</span></td><td><span class="math inline">\(D_3\)</span></td><td><span class="math inline">\(\theta_3\)</span></td></tr><tr class="even"><td>4</td><td>0</td><td><span class="math inline">\(L_3\)</span></td><td>0</td><td>0</td></tr></tbody></table></li><li><p>求末坐标系和初坐标系之间得变换矩阵 <spanclass="math inline">\(^0_4T\)</span></p><blockquote><p>两个相邻坐标系之间的变换矩阵通式为： <span class="math display">\[^{i-1}_iT =\begin{bmatrix}cos\theta_i&amp;-sin\theta_i&amp;0&amp;a_{i-1}\\cos\alpha_{i-1} sin\theta_i&amp;cos\alpha_{i-1}cos\theta_i&amp;-sin\alpha_{i-1} &amp;-d_isin\alpha_{i-1} \\sin\alpha_{i-1} sin\theta_i&amp;sin\alpha_{i-1}cos\theta_i&amp;cos\alpha_{i-1} &amp;d_icos\alpha_{i-1} \\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\\tag{7}\]</span></p></blockquote><p>首先，根据式（7），求出所有的两个相邻坐标系之间的变换矩阵为： <spanclass="math display">\[^0_1T =\begin{bmatrix}cos\theta_1&amp;-sin\theta_1&amp;0&amp;0\\sin\theta_1&amp;cos\theta_1&amp;0 &amp;0 \\0 &amp;0 &amp;1 &amp;0 \\0 &amp;0 &amp;0 &amp;1\\\end{bmatrix} \\\tag{8}\]</span></p><p><span class="math display">\[^1_2T =\begin{bmatrix}cos\theta_2&amp;-sin\theta_2&amp;0&amp;0\\0 &amp;0 &amp;1 &amp;D_2\\-sin\theta_2 &amp;-cos\theta_2 &amp;0 &amp;0 \\0 &amp;0 &amp;0 &amp;1\\\end{bmatrix} \\  \tag{9}\]</span></p><p><span class="math display">\[^2_3T =\begin{bmatrix}cos\theta_3&amp;-sin\theta_3&amp;0&amp;L_2\\sin\theta_3&amp;cos\theta_3&amp;0 &amp;0 \\0 &amp;0 &amp;1 &amp;D_3 \\0 &amp;0 &amp;0 &amp;1\\\end{bmatrix} \\\tag{10}\]</span></p><p><span class="math display">\[^3_4T =\begin{bmatrix}1 &amp;0 &amp;0 &amp;L_3\\0 &amp;1 &amp;0 &amp;0 \\0 &amp;0 &amp;1 &amp;0 \\0 &amp;0 &amp;0 &amp;1\\\end{bmatrix} \\\tag{11}\]</span></p><p>然后，将上述变换矩阵累乘得： <span class="math display">\[^0_4T = ^0_1T ^1_2T^2_3T^3_4T \\=\begin{bmatrix}c_1c_{23} &amp;-c_1s_{23} &amp;-s_1&amp;c_1(L_2c_2+L_3c_{23})-s_1(D_2+D_3)\\s_1c_{23} &amp;-s_1s_{23} &amp;c_1&amp;s_1(L_2c_2+L_3c_{23})+c_1(D_2+D_3) \\-s_{23} &amp;-c_{23} &amp;0 &amp;-L_2s_2-L_3s_{23} \\0 &amp;0 &amp;0 &amp;1\\\end{bmatrix} \\\tag{12}\]</span></p><blockquote><p>【注】<span class="math inline">\(c_1\)</span> 为 <spanclass="math inline">\(cos\theta_1\)</span>的简写，<spanclass="math inline">\(c_{23}\)</span> 为 <spanclass="math inline">\(cos(\theta_2+\theta_3)\)</span>的简写，其余类似。</p></blockquote></li><li><p>求末端点在0号坐标系中的表示</p><p>根据式（12），在0号坐标系表示末端点（4号坐标系的原点）为 <spanclass="math display">\[^0P_{origin_4} =\begin{bmatrix}c_1(L_2c_2+L_3c_{23})-s_1(D_2+D_3)\\s_1(L_2c_2+L_3c_{23})+c_1(D_2+D_3) \\-L_2s_2-L_3s_{23} \\\end{bmatrix} \\\tag{13}\]</span></p><p>式（13）即为式（1）描述的正运动学模型 <spanclass="math inline">\(\pmb{x} = f(\pmb{q}) \tag{1}\)</span>，其中，<spanclass="math inline">\(\pmb{x} =\ ^0P_{origin_4}=  [^0x_{origin_4}\^0y_{origin_4}\ ^0z_{origin_4}]^T\)</span>，<spanclass="math inline">\(\pmb{q} = [\theta_1 \ \theta_2 \\theta_3]^T\)</span> 。</p></li></ul><p><em>当然，上述矩阵的求解没有人会希望通过手算来解决，可以利用matlab写一个简单脚本进行计算：</em></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 用于生成变换矩阵.</span><br><span class="hljs-comment">% @filename: generate_T.m</span><br><span class="hljs-comment">% @functionname: generate_T</span><br><span class="hljs-comment">% @args: </span><br><span class="hljs-comment">%   alpha, a, d, theta.</span><br><span class="hljs-comment">% @return:</span><br><span class="hljs-comment">%   T.</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">T</span> = <span class="hljs-title">generate_T</span><span class="hljs-params">(alpha, a, d, theta)</span></span><br><span class="hljs-comment">% 这里的T矩阵是式（7）的矩阵</span><br>T = [<span class="hljs-built_in">cos</span>(theta) -<span class="hljs-built_in">sin</span>(theta) <span class="hljs-number">0</span> a;<br>     <span class="hljs-built_in">cos</span>(alpha)*<span class="hljs-built_in">sin</span>(theta) <span class="hljs-built_in">cos</span>(alpha)*<span class="hljs-built_in">cos</span>(theta) -<span class="hljs-built_in">sin</span>(alpha) -d*<span class="hljs-built_in">sin</span>(alpha);<br>     <span class="hljs-built_in">sin</span>(alpha)*<span class="hljs-built_in">sin</span>(theta) <span class="hljs-built_in">sin</span>(alpha)*<span class="hljs-built_in">cos</span>(theta) <span class="hljs-built_in">cos</span>(alpha) d*<span class="hljs-built_in">cos</span>(alpha);<br>     <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>];<br><br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 1. 计算末坐标系相对于初坐标系的变换矩阵</span><br><span class="hljs-comment">% 2. 在初坐标系中描述末坐标系的原点</span><br><span class="hljs-comment">% @filename: mian.m</span><br><br>clc,clear,close all;<br>syms th1 th2 th3;<br>syms l1 l2 l3;<br>syms d1 d2 d3;<br>syms PI;<br><br>T01 = generate_T(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, th1);<br>T12 = generate_T(-PI/<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, d2, th2);<br>T23 = generate_T(<span class="hljs-number">0</span>, l2, d3, th3);<br>T34 = generate_T(<span class="hljs-number">0</span>, l3, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>P = T01*T12*T23*T34;<br>P = subs(P,PI,<span class="hljs-built_in">pi</span>); <span class="hljs-comment">% For solving the problem: cos(pi/2) != 0.</span><br>P_simplify = simplify(P)<br><br>pos = P_simplify(<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><br><span class="hljs-comment">% jacobian(pos, [th1, th2, th3])</span><br><br></code></pre></td></tr></table></figure><h4 id="求雅可比矩阵">2.1.3 求雅可比矩阵</h4><p>根据式（2）对式（13）求偏导得： <span class="math display">\[\delta \pmb{x} =  \begin{bmatrix}-s_1(L_2c_2+L_3c_{23})-c_1(D_2+D_3) &amp;-c_1(L_2s_2+L_3s_{23})&amp;-L_3c_1s_{23}\\c_1(L_2c_2+L_3c_{23})-s_1(D_2+D_3) &amp;-s_1(L_2s_2+L_3s_{23})&amp;-L_3s_1s_{23}\\0 &amp;-L_2c_2-L_3c_{23} &amp;-L_3c_{23}\\\end{bmatrix}\delta \pmb{q}\tag{14}\]</span></p><p>由式（14）得雅可比矩阵为 <span class="math display">\[\pmb{J} =\begin{bmatrix}-s_1(L_2c_2+L_3c_{23})-c_1(D_2+D_3) &amp;-c_1(L_2s_2+L_3s_{23})&amp;-L_3c_1s_{23}\\c_1(L_2c_2+L_3c_{23})-s_1(D_2+D_3) &amp;-s_1(L_2s_2+L_3s_{23})&amp;-L_3s_1s_{23}\\0 &amp;-L_2c_2-L_3c_{23} &amp;-L_3c_{23}\\\end{bmatrix}\tag{15}\]</span></p><p><em>当然，雅可比的计算也可用代码完成，如下所示：</em></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 1. 计算末坐标系相对于初坐标系的变换矩阵</span><br><span class="hljs-comment">% 2. 在初坐标系中描述末坐标系的原点</span><br><span class="hljs-comment">% 3. 计算雅可比矩阵</span><br><span class="hljs-comment">% @filename: mian.m</span><br><br>clc,clear,close all;<br>syms th1 th2 th3;<br>syms l1 l2 l3;<br>syms d1 d2 d3;<br>syms PI;<br><br>T01 = generate_T(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, th1);<br>T12 = generate_T(-PI/<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, d2, th2);<br>T23 = generate_T(<span class="hljs-number">0</span>, l2, d3, th3);<br>T34 = generate_T(<span class="hljs-number">0</span>, l3, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>P = T01*T12*T23*T34;<br>P = subs(P,PI,<span class="hljs-built_in">pi</span>);<br>P_simplify = simplify(P)<br><br>pos = P_simplify(<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><br>jacobian(pos, [th1, th2, th3])<br><br></code></pre></td></tr></table></figure><h4 id="假设虚拟力">2.1.4 假设虚拟力</h4><p>假设用一个虚拟构件（弹簧阻尼器）连接机械臂末端和外界，将该虚拟构件产生的作用在机械臂末端点的虚拟力记为<spanclass="math inline">\(F\)</span>，可将虚拟力<spanclass="math inline">\(F\)</span>分解到三个方向，即 <spanclass="math display">\[\pmb{F} =\begin{bmatrix}F_x\\F_y\\F_z\\\end{bmatrix}=\begin{bmatrix}k_x &amp;0 &amp;0\\0 &amp;k_y &amp;0\\0 &amp;0 &amp;k_z\\\end{bmatrix}\begin{bmatrix}x_d - x\\y_d - y\\z_d - z\\\end{bmatrix}+\begin{bmatrix}b_x &amp;0 &amp;0\\0 &amp;b_y &amp;0\\0 &amp;0 &amp;b_z\\\end{bmatrix}\begin{bmatrix}\dot{x_d} - \dot{x}\\\dot{y_d} - \dot{y}\\\dot{z_d} - \dot{z}\\\end{bmatrix}\tag{16}\]</span></p><h4 id="求解扭矩">2.1.5 求解扭矩</h4><p>将式（15）、（16）代入式（6）可得关节力矩。</p><h4 id="代码">2.1.6 代码</h4><p><ahref="https://github.com/HuShanzhi/demo_quadruped_VMC">demo_quadruped_VMC</a></p><h2 id="参考">3 参考</h2><p>四足机器人对角小跑步态虚拟模型直觉控制方法研究</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>正逆运动学笔记</title>
    <link href="/2023/05/07/%E6%AD%A3%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/05/07/%E6%AD%A3%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="rotation-matrix">Rotation Matrix</h2><p>旋转矩阵的作用：</p><ol type="1"><li>描述物体的姿态；</li><li>将point由某一个frame的表述换到另一个和此frame有相对转动的frame上来表述；</li><li>...</li></ol><h2 id="homogeneous-transformation-matrix">Homogeneous TransformationMatrix</h2><p>齐次变换矩阵...</p><h2 id="forward-kinematics">Forward Kinematics</h2><h3 id="什么是正运动学">什么是正运动学</h3><p>正运动学就是通过关节的驱动来推出机器末端的位姿。</p><h3 id="建立关节坐标系">建立关节坐标系</h3><p>建立坐标系的方法有两种：一种是<strong>克雷格（CraigVersion）</strong>；<del>另一种是<strong>Standard</strong></del>。</p><figure><img src="正逆运动学笔记/机械手臂几何描述方式示意图-5420114.png"alt="图1 机械手臂几何描述方式示意图" /><figcaption aria-hidden="true">图1机械手臂几何描述方式示意图</figcaption></figure><p>如图1所示，对于一个关节（无论是转动关节还是移动关节），总能找到一个关节轴，记为Axis。当然对于转动关节，Axis就是转轴；对于移动关节，Axis就是移动轴。两个相邻的Axis之间有两种情况：一种是异面直线，一种是共面且平行直线。所以，两个相邻的Axis之间一定存在一条直线。</p><p>如图1所示，对于一个由Joint和Link复合的一个机械结构，一般通过4个参数进行描述<spanclass="math inline">\(\alpha、a、d、\theta\)</span>。其中，<spanclass="math inline">\(\alpha\)</span>表示两个Joint转轴之间的角度，<spanclass="math inline">\(a\)</span>表示两个转轴之间的距离，<spanclass="math inline">\(d\)</span>表示两个Link之间的偏移值，<spanclass="math inline">\(\theta\)</span>表示Joint的转动角度。（<spanclass="math inline">\(\alpha_i, a_i, d_i,\theta_i\)</span>）可以用来表示第i个Joint的信息。对于转动关节来说，它的<spanclass="math inline">\(\theta\)</span>是可变参数；对于移动关节来说，它的<spanclass="math inline">\(d\)</span>是可变参数。</p><p>如图2所示，需要给每个Joint建立坐标系（<spanclass="math inline">\(\widehat{X}_i, \widehat{Y}_i,\widehat{Z}_i\)</span>），其中，<spanclass="math inline">\(\widehat{Z}_i\)</span>沿转轴Axis（转动或移动）的方向。<spanclass="math inline">\(\widehat{X}_i\)</span>有两种情况：一是当<spanclass="math inline">\(a_i \neq 0\)</span>时，它沿着<spanclass="math inline">\(a_i\)</span>的方向；二是当<spanclass="math inline">\(a_i = 0\)</span>时，它与<spanclass="math inline">\(\widehat{Z}_i和\)</span><spanclass="math inline">\(\widehat{Z}_{i+1}\)</span>两者垂直（i.e. 它为<spanclass="math inline">\(\widehat{Z}_i和\)</span><spanclass="math inline">\(\widehat{Z}_{i+1}\)</span>的叉积的单位向量）。<spanclass="math inline">\(\widehat{Y}_i\)</span>与<spanclass="math inline">\(\widehat{X}_i和\)</span><spanclass="math inline">\(\widehat{Z}_{i}\)</span>两者垂直，且遵循右手定则，即<spanclass="math inline">\(\widehat{Y}_i = \widehat{Z}_{i} \times\widehat{X}_{i}\)</span>。<strong>注意Z和X的顺序。</strong></p><figure><img src="正逆运动学笔记/建立关节坐标系-5420114.png"alt="图2 建立关节坐标系" /><figcaption aria-hidden="true">图2 建立关节坐标系</figcaption></figure><p>上述为普遍地建立坐标系的方法。此外，还有两种特殊情况：一是对于地杆Link0，为了简化计算，<strong>一般都将Link 1的坐标系作为Link0的坐标系。</strong>如果Joint 1是转动关节，则把<spanclass="math inline">\(\theta_1 = 0\)</span>时的Link 1的坐标系作为Link0的坐标系；如果Joint 1是移动关节，则把<span class="math inline">\(d_1  =0\)</span>时的Link 1的坐标系作为Link 0的坐标系。二是对于最后一个Linkn，Joint n无法确定一个<spanclass="math inline">\(a_n\)</span>，进而无法确定<spanclass="math inline">\(\widehat{X}_n\)</span>。一般的解决办法是让<spanclass="math inline">\(\theta_n=0\)</span>时的<spanclass="math inline">\(\widehat{X}_n\)</span>的方向与<spanclass="math inline">\(\widehat{X}_{n-1}\)</span>保持相同（<del>【注】：我感觉是从末端向Axisn做垂线，然后用垂线来确定<spanclass="math inline">\(\widehat{X}_n\)</span></del>）。</p><figure><img src="正逆运动学笔记/Link0建立坐标系-5420114.png"alt="图3 Link 0建立坐标系" /><figcaption aria-hidden="true">图3 Link 0建立坐标系</figcaption></figure><figure><img src="正逆运动学笔记/Linkn建立坐标系-5420114.png"alt="图4 Link n建立坐标系" /><figcaption aria-hidden="true">图4 Link n建立坐标系</figcaption></figure><h3 id="杆件之间的变换矩阵">杆件之间的变换矩阵</h3><p><span class="math display">\[^{i-1}P = ^{i-1}_iT^iP \tag{1}\]</span></p><p><img src="正逆运动学笔记/两个杆件坐标系转化过程示意图-5420114.png"alt="图5 两个杆件坐标系转化过程示意图" /> <span class="math display">\[^{i-1}P = ^{i-1}_RT ^R_QT ^Q_PT ^P_iT ^iP \tag{2}\]</span></p><p><span class="math display">\[^{i-1}_iT =^{i-1}_RT ^R_QT ^Q_PT ^P_iT \\= T_{\widehat{X}_{i-1}}(\alpha_{i-1})T_{\widehat{X}_{R}}(a_{i-1})  T_{\widehat{Z}_{Q}}(\theta_{i})T_{\widehat{Z}_{P}}(d_{i}) \\=  \begin{bmatrix}  cos\theta_i&amp;-sin\theta_i&amp;0&amp;a_{i-1}\\cos\alpha_{i-1} sin\theta_i&amp;cos\alpha_{i-1}cos\theta_i&amp;sin\alpha_{i-1} &amp;d_isin\alpha_{i-1} \\-sin\alpha_{i-1} sin\theta_i&amp;-sin\alpha_{i-1}cos\theta_i&amp;cos\alpha_{i-1} &amp;d_icos\alpha_{i-1} \\0&amp;0&amp;0&amp;1\\  \end{bmatrix} \\  \tag{3}\]</span></p><p><del><code>【注】式（3）的结果和林沛群教授课件上的不同，个人感觉是他出错了。</code></del></p><p><code>【注】式（3）有误，应为式（3b）。林是对的。</code> <spanclass="math display">\[^{i-1}_iT =^{i-1}_RT ^R_QT ^Q_PT ^P_iT \\= T_{\widehat{X}_{i-1}}(\alpha_{i-1})T_{\widehat{X}_{R}}(a_{i-1})  T_{\widehat{Z}_{Q}}(\theta_{i})T_{\widehat{Z}_{P}}(d_{i}) \\=  \begin{bmatrix}  cos\theta_i&amp;-sin\theta_i&amp;0&amp;a_{i-1}\\cos\alpha_{i-1} sin\theta_i&amp;cos\alpha_{i-1}cos\theta_i&amp;-sin\alpha_{i-1} &amp;-d_isin\alpha_{i-1} \\sin\alpha_{i-1} sin\theta_i&amp;sin\alpha_{i-1}cos\theta_i&amp;cos\alpha_{i-1} &amp;d_icos\alpha_{i-1} \\0&amp;0&amp;0&amp;1\\  \end{bmatrix} \\  \tag{3b}\]</span></p><p><span class="math display">\[T_{\widehat{X}_{i-1}}(\alpha_{i-1}) =\begin{bmatrix}&amp;&amp;&amp;0\\&amp;R_{\widehat{X}_{i-1}}(\alpha_{i-1})&amp;&amp;0\\&amp;&amp;&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\=  \begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;cos\alpha_{i-1}&amp;sin\alpha_{i-1}&amp;0\\0&amp;-sin\alpha_{i-1}&amp;cos\alpha_{i-1}&amp;0\\0&amp;0&amp;0&amp;1\\  \end{bmatrix} \\  \tag{4}\]</span></p><p><code>【注】式（3）的错误是由式（4）的错误引起的，式（4）应为式（4b）。但是，目前还不知道为什么是式（4b）。</code></p><blockquote><p>现在解释一下为什么是 4b 而不是 4：（<strong>这是因为 Rotation Matrix部分没学好。</strong>）</p><p>我们从 <span class="math inline">\(\widehat{X}_{i-1}\)</span>的方向向 <span class="math inline">\(\widehat{X}_{i-1}\)</span>的负方向看去，坐标系 <span class="math inline">\(\{i-1\}\)</span> 绕<span class="math inline">\(\widehat{X}\)</span>轴<strong>顺时针</strong>旋转 <spanclass="math inline">\(\alpha\)</span> 度获得坐标系 <spanclass="math inline">\(\{R\}\)</span> 。然后，将坐标系 <spanclass="math inline">\(\{R\}\)</span> 的 <spanclass="math inline">\(\widehat{Z}_R\)</span> 和 <spanclass="math inline">\(\widehat{Y}_R\)</span> 轴依次向坐标系 <spanclass="math inline">\(\{i-1\}\)</span>做投影，应该是获得式（4）而不是式（4b），<strong>但是</strong>，<spanclass="math inline">\(\alpha\)</span>角是有方向的，顺时针旋转为负。因此，式（4）应该改为： <spanclass="math display">\[T_{\widehat{X}_{i-1}}(-\alpha_{i-1}) =\begin{bmatrix}&amp;&amp;&amp;0\\&amp;R_{\widehat{X}_{i-1}}(-\alpha_{i-1})&amp;&amp;0\\&amp;&amp;&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;cos(-\alpha_{i-1})&amp;sin(-\alpha_{i-1})&amp;0\\0&amp;-sin(-\alpha_{i-1})&amp;cos(-\alpha_{i-1})&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\\]</span></p><p>做三角变换可得到式 （4b）。</p></blockquote><p><span class="math display">\[T_{\widehat{X}_{i-1}}(\alpha_{i-1}) =\begin{bmatrix}&amp;&amp;&amp;0\\&amp;R_{\widehat{X}_{i-1}}(\alpha_{i-1})&amp;&amp;0\\&amp;&amp;&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\=  \begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;cos\alpha_{i-1}&amp;-sin\alpha_{i-1}&amp;0\\0&amp;sin\alpha_{i-1}&amp;cos\alpha_{i-1}&amp;0\\0&amp;0&amp;0&amp;1\\  \end{bmatrix} \\  \tag{4b}\]</span></p><p><span class="math display">\[T_{\widehat{X}_{R}}(a_{i-1}) =\begin{bmatrix}1&amp;0&amp;0&amp;\\0&amp;1&amp;0&amp;P_{\widehat{X}_{R}}(a_{i-1})\\0&amp;0&amp;1&amp;\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\=  \begin{bmatrix}  1&amp;0&amp;0&amp;a_{i-1}\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\\  \end{bmatrix} \\  \tag{5}\]</span></p><p><span class="math display">\[T_{\widehat{Z}_{Q}}(\theta_{i})=\begin{bmatrix}&amp;&amp;&amp;0\\&amp;R_{\widehat{Z}_{Q}}(\theta_{i})&amp;&amp;0\\&amp;&amp;&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\=  \begin{bmatrix}cos\theta_{i}&amp;-sin\theta_{i}&amp;0&amp;0\\sin\theta_{i}&amp;cos\theta_{i}&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\\  \end{bmatrix} \\  \tag{6}\]</span></p><p><span class="math display">\[T_{\widehat{Z}_{P}}(d_{i})  =\begin{bmatrix}1&amp;0&amp;0&amp;\\0&amp;1&amp;0&amp;P_{\widehat{Z}_{P}}(d_{i})\\0&amp;0&amp;1&amp;\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\=  \begin{bmatrix}  1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;d_{i}\\0&amp;0&amp;0&amp;1\\  \end{bmatrix} \\  \tag{7}\]</span></p><p>进一步，第一个杆件和最后一个杆件之间的变换矩阵为式（8）。</p><p><span class="math display">\[^{0}_nT = ^{0}_1T^{1}_2T^{2}_3T ... ^{n-2}_{n-1}T^{n-1}_{n}T    \tag{8}\]</span></p><h3 id="instance">Instance</h3><p>我们通过一个简单的二连杆进行一次正运动学推导。</p><figure><img src="正逆运动学笔记/二连杆示意图-5420114.png"alt="图6 二连杆示意图" /><figcaption aria-hidden="true">图6 二连杆示意图</figcaption></figure><p>给图中二连杆的各个关节建立坐标系。</p><blockquote><p>【分析】：</p><ul><li>给Joint 1建立坐标系（即第1个坐标系）：</li></ul><ol type="1"><li><p>Joint 1 和 Joint 2 的转轴Axis垂直于平面，且相互平行。因此，<spanclass="math inline">\(\alpha_1=0\)</span>，<spanclass="math inline">\(a_1=\{link1的长度\}\)</span>；</p></li><li><p><span class="math inline">\(\widehat{X_1}\)</span>的方向沿<spanclass="math inline">\(a_1\)</span>，<spanclass="math inline">\(\widehat{Z_1}\)</span>的方向设为沿Joint1的转轴向外，进而，可得<span class="math inline">\(\widehat{Y_1} =\widehat{X_1}  \times \widehat{Z_1}\)</span>。</p></li></ol><ul><li>给基座建立坐标系（即第0个坐标系）：</li></ul><ol type="1"><li>把<spanclass="math inline">\(\theta_1=0\)</span>时的第1个坐标系作为第0个坐标系。</li></ol><ul><li>给Joint 2建立坐标系（即第2个坐标系）：</li></ul><ol type="1"><li>首先最关键的是要确定<spanclass="math inline">\(\widehat{X_2}\)</span>的方向。将<spanclass="math inline">\(\widehat{X_1}\)</span>的方向作为<spanclass="math inline">\(\theta_2=0\)</span>时的<spanclass="math inline">\(\widehat{X_2}\)</span>的方向；</li><li><span class="math inline">\(\widehat{Z_2}\)</span>的方向设为沿Joint2的转轴向外，进而，可得<span class="math inline">\(\widehat{Y_2} =\widehat{X_2}  \times \widehat{Z_2}\)</span>。</li></ol></blockquote><figure><img src="正逆运动学笔记/二连杆建立关节坐标系-5420114.png"alt="图7 二连杆建立关节坐标系" /><figcaption aria-hidden="true">图7 二连杆建立关节坐标系</figcaption></figure><table><thead><tr class="header"><th><span class="math inline">\(i\)</span></th><th><span class="math inline">\(\alpha_{i-1}\)</span></th><th><span class="math inline">\(a_{i-1}\)</span></th><th><span class="math inline">\(d_i\)</span></th><th><span class="math inline">\(\theta_{i}\)</span></th></tr></thead><tbody><tr class="odd"><td>1</td><td>0</td><td>0</td><td>0</td><td><span class="math inline">\(\theta_1\)</span></td></tr><tr class="even"><td>2</td><td>0</td><td><span class="math inline">\(L_1\)</span></td><td>0</td><td><span class="math inline">\(\theta_2\)</span></td></tr></tbody></table><p>记二连杆的末端点为<span class="math inline">\(P\)</span>，令<spanclass="math inline">\(P\)</span>在 Joint 2 的坐标系下的位置为<spanclass="math inline">\(^2P = (L_2, 0,0)^T\)</span>。假设基坐标系为世界坐标系。 <span class="math display">\[\begin{bmatrix}&amp; \\^0P \\&amp; \\1 \\  \end{bmatrix}  = ^0_1T ^1_2T\begin{bmatrix}&amp; \\^2P \\&amp; \\1 \\  \end{bmatrix}  \tag{9}\]</span></p>$$ ^0P =<span class="math display">\[\begin{bmatrix}cos\theta_1&amp;-sin\theta_1&amp;0&amp;a_{0}\\cos\alpha_{0} sin\theta_1&amp;cos\alpha_{0}cos\theta_1&amp;sin\alpha_{0} &amp;d_1sin\alpha_{0} \\-sin\alpha_{0} sin\theta_1&amp;-sin\alpha_{0}cos\theta_1&amp;cos\alpha_{0} &amp;d_1cos\alpha_{0} \\0&amp;0&amp;0&amp;1\\  \end{bmatrix}\]</span><pre><code class="hljs">\begin&#123;bmatrix&#125;</code></pre><p>cos<em>2&amp;-sin<em>2&amp;0&amp;a</em>{1}\ cos</em>{1}sin<em>2&amp;cos</em>{1} cos<em>2&amp;sin</em>{1} &amp;d_2sin<em>{1} \-sin</em>{1} sin<em>2&amp;-sin</em>{1} cos<em>2&amp;cos</em>{1}&amp;d_2cos_{1} \ 0&amp;0&amp;0&amp;1\ \end{bmatrix}</p>{^2P} \ =<span class="math display">\[\begin{bmatrix}cos\theta_1&amp;-sin\theta_1&amp;0&amp;0\\sin\theta_1&amp;cos\theta_1&amp;0 &amp;0 \\0&amp;0&amp;1 &amp;0 \\0&amp;0&amp;0&amp;1\\  \end{bmatrix}\]</span><pre><code class="hljs">\begin&#123;bmatrix&#125;</code></pre>cos_2&amp;-sin<em>2&amp;0&amp;L</em>{1}\ sin_2&amp;cos_2&amp;0 &amp;0 \0&amp;0&amp;1 &amp;0 \ 0&amp;0&amp;0&amp;1\ \end{bmatrix}<br />{^2P} \ =<span class="math display">\[\begin{bmatrix}cos\theta_{1}cos\theta_2-sin\theta_{1}sin\theta_{2}&amp;-cos\theta_{1}sin\theta_2-sin\theta_{1}cos\theta_{2}&amp;0&amp;L_{1}cos\theta_{1}\\sin\theta_1cos\theta_{2}+cos\theta_{1}sin\theta_{2}&amp;-sin\theta_{1}sin\theta_{2}+cos\theta_{1}cos\theta_2&amp;0&amp;L_1sin\theta_{1} \\0&amp;0&amp;1 &amp;0 \\0&amp;0&amp;0&amp;1\\  \end{bmatrix}\]</span><pre><code class="hljs">  \begin&#123;bmatrix&#125;</code></pre>L_{2}\ 0 \ 0 \ 1\ \end{bmatrix} \ =<span class="math display">\[\begin{bmatrix}(cos\theta_{1}cos\theta_2-sin\theta_{1}sin\theta_{2})L_2+L_{1}cos\theta_{1}\\(sin\theta_1cos\theta_{2}+cos\theta_{1}sin\theta_{2})L_2+L_1sin\theta_{1}\\0 \\1\\  \end{bmatrix}\]</span>\ =<span class="math display">\[\begin{bmatrix}cos(\theta_{1}+\theta_{2})L_2+L_{1}cos\theta_{1}\\sin(\theta_{1}+\theta_{2})L_2+L_1sin\theta_{1} \\0 \\1\\  \end{bmatrix}\]</span><p> $$</p><h2 id="inverse-kinematics">Inverse Kinematics</h2><p>### 什么是逆运动学</p><p>逆运动学就是通过机器末端的位姿来反推各个关节的驱动。</p><h3 id="求解方法">求解方法</h3><ul><li>解析法<ul><li>代数和几何方法</li></ul></li><li>数值法<ul><li>用计算机试值</li></ul></li><li>目前大多数机械臂设计成具有解析解<ul><li>对于一个六轴机械臂，设计时让它的相邻三轴相交一点，一般这样的手臂就能找到解析解。目前，机械臂多将后三个轴相交一点。</li></ul></li></ul><h3 id="instance-1">Instance</h3><figure><img src="正逆运动学笔记/二连杆逆运动学-5420114.png"alt="图8 二连杆逆运动学" /><figcaption aria-hidden="true">图8 二连杆逆运动学</figcaption></figure>假设基坐标系为世界坐标系。令<spanclass="math inline">\(P\)</span>为目标点，已知<spanclass="math inline">\(P\)</span>点在世界坐标系的坐标为<spanclass="math inline">\((x, y, z)=(x, y, 0)\)</span>，进而可以推出Joint2坐标系原点的坐标为<span class="math inline">\((x-L_2cos\varphi,y-L_2sin\varphi, 0)\)</span>，因此Joint2坐标系相对于世界坐标系的变换矩阵<spanclass="math inline">\(^0_2T\)</span>可以表示为 $$<span class="math display">\[\begin{bmatrix}cos\varphi&amp;-sin\varphi&amp;0&amp;x-L_2cos\varphi\\sin\varphi&amp;cos\varphi&amp;0&amp;y-L_2sin\varphi \\0&amp;0&amp;1&amp;0 \\0&amp;0&amp;0&amp;1\\  \end{bmatrix}\]</span><span class="math display">\[根据正运动学公式$^0_2T$还可以表示为\]</span><span class="math display">\[\begin{bmatrix}cos\theta_{1}cos\theta_2-sin\theta_{1}sin\theta_{2}&amp;-cos\theta_{1}sin\theta_2-sin\theta_{1}cos\theta_{2}&amp;0&amp;L_{1}cos\theta_{1}\\sin\theta_1cos\theta_{2}+cos\theta_{1}sin\theta_{2}&amp;-sin\theta_{1}sin\theta_{2}+cos\theta_{1}cos\theta_2&amp;0&amp;L_1sin\theta_{1} \\0&amp;0&amp;1 &amp;0 \\0&amp;0&amp;0&amp;1\\  \end{bmatrix}\]</span><span class="math display">\[根据三角公式进一步化简得\]</span><span class="math display">\[\begin{bmatrix}cos(\theta_{1}+\theta_2)&amp;-sin(\theta_1+\theta_{2})&amp;0&amp;L_{1}cos\theta_{1}\\sin(\theta_1+\theta_{2})&amp;cos(\theta_{1}+\theta_{2})&amp;0&amp;L_1sin\theta_{1} \\0&amp;0&amp;1 &amp;0 \\0&amp;0&amp;0&amp;1\\  \end{bmatrix}\]</span><p> $$</p><h4 id="代数法">代数法</h4><p>联立式（11）和（13）得 <span class="math display">\[\begin{cases}cos\varphi= cos(\theta_1+\theta_2)\\sin\varphi= sin(\theta_1+\theta_2)\\x-L_2cos\varphi=L_1cos\theta_1\\y-L_2sin\varphi=L_1sin\theta_1\\\end{cases}\tag{14}\]</span></p><p><span class="math display">\[\begin{cases}x= L_1cos\theta_1 + L_2cos(\theta_1+\theta_2)\\y= L_1sin\theta_1 + L_2sin(\theta_1+\theta_2)\\\end{cases}\tag{15}\]</span></p><p><span class="math display">\[x^2 + y^2 = L_1^2 + L_2^2 + 2L_1L_2[cos\theta_1cos(\theta_1+\theta_2) +sin\theta_1sin(\theta_1+\theta_2)] \\x^2 + y^2 = L_1^2 + L_2^2 + 2L_1L_2cos\theta_2\tag{16}\]</span></p><p><span class="math display">\[\theta_2 = \pm arccos(\frac{x^2+y^2-L_1^2-L_2^2}{2L_1L_2})\]</span></p><p><span class="math display">\[\begin{cases}x= L_1cos\theta_1 + L_2cos(\theta_1+\theta_2) =(L_1+L_2cos\theta_2)cos\theta_1+(-L_2sin\theta_2)sin\theta_1\\y= L_1sin\theta_1 + L_2sin(\theta_1+\theta_2) =(L_1+L_2cos\theta_2)sin\theta_1 + (\, \, \, \,\,  L_2sin\theta_2)cos\theta_1\\\end{cases}\tag{17}\]</span></p><p><span class="math display">\[\begin{cases}x \triangleq k_1cos\theta_1 - k_2sin\theta_1 \\y \triangleq k_1sin\theta_1 + k_2cos\theta_1\\\end{cases}\tag{18}\]</span></p><p><span class="math display">\[r = + \sqrt{k_1^2+k_2^2} \\\gamma=arctan(k_2/k_1)\tag{19}\]</span></p><p><span class="math display">\[k_1 = r cos\gamma \\k_2 = r sin\gamma\tag{20}\]</span></p><p><span class="math display">\[\begin{cases}\frac{x}{r} = cos\gamma cos\theta_1 - sin\gamma sin\theta_1 = cos(\gamma+ \theta_1) \\\frac{y}{r} = cos\gamma sin\theta_1 - sin\gamma cos\theta_1 = sin(\gamma+ \theta_1)\end{cases}\tag{21}\]</span></p><p><span class="math display">\[tan(\gamma + \theta_1) = y/x \\\theta_1 = arctan(y/x) - \gamma =  arctan(y/x) - arctan(k_2/k_1)\tag{22}\]</span></p><h4 id="几何法">几何法</h4><figure><img src="正逆运动学笔记/二连杆逆运动学几何求解法-5420114.png"alt="图9 二连杆逆运动学几何求解法" /><figcaption aria-hidden="true">图9 二连杆逆运动学几何求解法</figcaption></figure><p>连接<span class="math inline">\(P\)</span>点和基坐标系原点，记为<spanclass="math inline">\(L_0\)</span>，<span class="math inline">\(L_0 =\sqrt{x^2+y^2}\)</span>。对三角形<spanclass="math inline">\(\bigtriangleup_{L_0L_1L_2}\)</span>做一个余弦定理得<span class="math display">\[L_0^2 = L_1^2 + L_2^2 - 2L_1L_2cos(\pi-\theta_2)\tag{23}\]</span> 进而，解得 <span class="math display">\[cos\theta_2=\frac{x^2+y^2-L_1^2-L_2^2}{2L_1L_2}\\\theta_2 = \pm arccos(\frac{x^2+y^2-L_1^2-L_2^2}{2L_1L_2})\tag{24}\]</span> 由于<spanclass="math inline">\(\varphi\)</span>的限制，上式中<spanclass="math inline">\(\theta_2\)</span>应取正值。然后，可求出<spanclass="math inline">\(\theta_1\)</span>为：<spanclass="math inline">\(\theta_1 = \varphi - \theta_2\)</span>。</p><h2 id="matlab验证">MATLAB验证</h2><h3 id="验证正运动学">验证正运动学</h3><p>二连杆采用Modified DH创建的DH表如下：</p><table><thead><tr class="header"><th><span class="math inline">\(i\)</span></th><th><span class="math inline">\(\alpha_{i-1}\)</span></th><th><span class="math inline">\(a_{i-1}\)</span></th><th><span class="math inline">\(d_i\)</span></th><th><span class="math inline">\(\theta_{i}\)</span></th></tr></thead><tbody><tr class="odd"><td>1</td><td>0</td><td>0</td><td>0</td><td><span class="math inline">\(\theta_1=\pi/2\)</span></td></tr><tr class="even"><td>2</td><td>0</td><td><span class="math inline">\(L_1=5\)</span></td><td>0</td><td><span class="math inline">\(\theta_2 = -\pi/2\)</span></td></tr><tr class="odd"><td>3</td><td>0</td><td><span class="math inline">\(L_2=3\)</span></td><td>0</td><td>0</td></tr></tbody></table><p>利用Robotics SystemToolbox求解正运动学（这里作为标准答案检验我们的矩阵公式法求解的结果是否为真）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 使用的版本是matlab 2021b.</span><br><span class="hljs-comment">% 利用Robotics System Toolbox对平面二连杆进行正运动学计算.</span><br><span class="hljs-comment">% 利用改进D-H（MDH）法建立多轴机器人</span><br>clc;<br>clear;<br>L(<span class="hljs-number">1</span>)=Link(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;alpha&#x27;</span>, <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;offset&#x27;</span>,<span class="hljs-built_in">pi</span>/<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;modified&#x27;</span>);<br>L(<span class="hljs-number">2</span>)=Link(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;alpha&#x27;</span>, <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;offset&#x27;</span>,-<span class="hljs-built_in">pi</span>/<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;modified&#x27;</span>);<br>L(<span class="hljs-number">3</span>)=Link(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;alpha&#x27;</span>, <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;offset&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;modified&#x27;</span>);<br><br>robot = SerialLink( L,<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;平面二连杆&#x27;</span>) ; <br><br>robot.display();<span class="hljs-comment">% 展示出机器人的信息</span><br>view(<span class="hljs-number">3</span>)<br>teach(robot);<span class="hljs-comment">% 调出示教滑块</span><br><br></code></pre></td></tr></table></figure><figure><imgsrc="正逆运动学笔记/利用Robotics%20System%20Toolbox的正运动学求解结果-5420114.png"alt="图10 利用Robotics System Toolbox的正运动学求解结果" /><figcaption aria-hidden="true">图10 利用Robotics SystemToolbox的正运动学求解结果</figcaption></figure><p>可以看到末端点的坐标为<span class="math inline">\([3, 5,0]\)</span>。</p><p>利用矩阵公式求解正运动学</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 用于生成一个变换矩阵.</span><br><span class="hljs-comment">% file: generate_T.m</span><br><span class="hljs-comment">% 函数名: generate_T.</span><br><span class="hljs-comment">% Args: </span><br><span class="hljs-comment">%   alpha, a, d, theta.</span><br><span class="hljs-comment">% Return:</span><br><span class="hljs-comment">%   T.</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">T</span> = <span class="hljs-title">generate_T</span><span class="hljs-params">(alpha, a, d, theta)</span></span><br><span class="hljs-comment">% 这里的T矩阵是式（3b）的矩阵</span><br>T = [<span class="hljs-built_in">cos</span>(theta) -<span class="hljs-built_in">sin</span>(theta) <span class="hljs-number">0</span> a;<br>         <span class="hljs-built_in">cos</span>(alpha)*<span class="hljs-built_in">sin</span>(theta) <span class="hljs-built_in">cos</span>(alpha)*<span class="hljs-built_in">cos</span>(theta) -<span class="hljs-built_in">sin</span>(alpha) -d*<span class="hljs-built_in">sin</span>(alpha);<br>         <span class="hljs-built_in">sin</span>(alpha)*<span class="hljs-built_in">sin</span>(theta) <span class="hljs-built_in">sin</span>(alpha)*<span class="hljs-built_in">cos</span>(theta) <span class="hljs-built_in">cos</span>(alpha) d*<span class="hljs-built_in">cos</span>(alpha);<br>         <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 使用的版本是matlab 2021b.</span><br><span class="hljs-comment">% file: forward_kinematics_formula.m</span><br><span class="hljs-comment">% 利用矩阵公式对平面二连杆进行正运动学计算.</span><br><span class="hljs-comment">% 利用改进D-H（MDH）法建立多轴机器人</span><br>T1 = generate_T(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">pi</span>/<span class="hljs-number">2</span>);<br>T2 = generate_T(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, -<span class="hljs-built_in">pi</span>/<span class="hljs-number">2</span>);<br>T3 = generate_T(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>P = T1*T2*T3<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs matlab">运行结果：<br>&gt;&gt; forward_kinematics_formula<br><br>P =<br><br>    <span class="hljs-number">1.0000</span>         <span class="hljs-number">0</span>         <span class="hljs-number">0</span>    <span class="hljs-number">3.0000</span><br>         <span class="hljs-number">0</span>    <span class="hljs-number">1.0000</span>         <span class="hljs-number">0</span>    <span class="hljs-number">5.0000</span><br>         <span class="hljs-number">0</span>         <span class="hljs-number">0</span>    <span class="hljs-number">1.0000</span>         <span class="hljs-number">0</span><br>         <span class="hljs-number">0</span>         <span class="hljs-number">0</span>         <span class="hljs-number">0</span>    <span class="hljs-number">1.0000</span><br></code></pre></td></tr></table></figure><p>可以看到末端点的坐标也为<span class="math inline">\([3, 5,0]\)</span>。</p><h3 id="验证逆运动学">验证逆运动学</h3><p>利用Robotics System Toolbox对平面二连杆进行逆运动学计算</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 使用的版本是matlab 2021b.</span><br><span class="hljs-comment">% file: inverse_kinematics_RT.m</span><br><span class="hljs-comment">% 利用Robotics System Toolbox对平面二连杆进行逆运动学计算.</span><br><span class="hljs-comment">% 利用改进D-H（MDH）法建立多轴机器人</span><br><span class="hljs-comment">% clc;</span><br>clear;<br>L(<span class="hljs-number">1</span>)=Link(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;alpha&#x27;</span>, <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;offset&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;modified&#x27;</span>);<br>L(<span class="hljs-number">2</span>)=Link(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;alpha&#x27;</span>, <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;offset&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;modified&#x27;</span>);<br>L(<span class="hljs-number">3</span>)=Link(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;alpha&#x27;</span>, <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;offset&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;modified&#x27;</span>);<br><br>robot = SerialLink( L,<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;平面二连杆&#x27;</span>) ; <br><br><span class="hljs-comment">%% 普通机器人的示教展示</span><br><span class="hljs-comment">% robot.display();% 展示出机器人的信息</span><br>view(<span class="hljs-number">3</span>)<br>teach(robot);<span class="hljs-comment">% 调出示教滑块</span><br><br><span class="hljs-comment">%% 机器人的正解函数</span><br><br>theta=[<span class="hljs-built_in">pi</span>/<span class="hljs-number">4</span>,-<span class="hljs-built_in">pi</span>/<span class="hljs-number">3</span>, <span class="hljs-number">0</span>];<br>robot.<span class="hljs-built_in">plot</span>(theta);<br>p=robot.fkine(theta)<br><br><span class="hljs-comment">%% 机器人的逆解</span><br>mask = [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>];<br>q=ikine(robot,p,<span class="hljs-string">&#x27;mask&#x27;</span>,mask)<br>robot.<span class="hljs-built_in">plot</span>(q);<span class="hljs-comment">%输出机器人模型，后面的三个角为输出时的theta姿态</span><br><br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab">运行结果：<br>&gt;&gt; inverse_kinematics_RT<br> <br>p = <br>    <span class="hljs-number">0.9659</span>    <span class="hljs-number">0.2588</span>         <span class="hljs-number">0</span>     <span class="hljs-number">6.433</span><br>   <span class="hljs-number">-0.2588</span>    <span class="hljs-number">0.9659</span>         <span class="hljs-number">0</span>     <span class="hljs-number">2.759</span><br>         <span class="hljs-number">0</span>         <span class="hljs-number">0</span>         <span class="hljs-number">1</span>         <span class="hljs-number">0</span><br>         <span class="hljs-number">0</span>         <span class="hljs-number">0</span>         <span class="hljs-number">0</span>         <span class="hljs-number">1</span><br><br>q =<br><br>    <span class="hljs-number">0.0249</span>    <span class="hljs-number">1.0472</span>         <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>利用矩阵公式求解逆运动学</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前言</title>
    <link href="/2023/05/04/%E5%89%8D%E8%A8%80/"/>
    <url>/2023/05/04/%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>2022年初，我曾经搭建过一次个人博客，也陆续写了几篇博文，但最终没有坚持下去，因为总感觉自己写的技术文章是在抄文档，对自己的帮助也不是很大，而且我工作中的组长也一直给我灌输这种博文毫无意义的思想。</p><p>然而，由于近半年学的东西很杂，我发现很多知识没有得到系统地学习和进一步串联巩固，因此，还是想把写博客的习惯捡起来。于是，我在2023年5月4日第二次搭建了自己的博客。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
