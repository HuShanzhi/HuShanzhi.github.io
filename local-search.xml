<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动态矩阵控制</title>
    <link href="/2025/09/16/%E5%8A%A8%E6%80%81%E7%9F%A9%E9%98%B5%E6%8E%A7%E5%88%B6/"/>
    <url>/2025/09/16/%E5%8A%A8%E6%80%81%E7%9F%A9%E9%98%B5%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>动态矩阵控制（DMC）是一种基于对象阶跃响应的预测控制算法，因而适用于渐近稳定的线性对象。<u>对于弱非线性对象，可在工作点处首先线性化；对于不稳定对象，可先用常规PID 控制使其稳定，然后再使用 DMC 算法。</u></p><p>DMC 算法包括预测模型、滚动优化和反馈校正3个部分。</p><h2 id="先验知识">先验知识</h2><h3 id="单位阶跃信号">单位阶跃信号</h3><p><span class="math display">\[\varepsilon(t) =\begin{cases}0, &amp; t &lt; 0 \\\\1, &amp; t \geq 0\end{cases}\tag{1}\]</span></p><p><img src="单位阶跃信号-8008603.png" alt="图1 单位阶跃信号" width="30%"></p><h3 id="自衡对象和积分对象">自衡对象和积分对象</h3><p>工业过程中常见的过程有自衡和非自衡两种，下图显示了两个过程对输出阶跃变化的理想化趋势。左边的过程是非积分对象，也叫自衡对象；右边的过程是非自衡对象，也叫积分对象。如下图左侧所示，自衡对象能够响应控制器输出并逐渐达到新的稳态操作点，典型的自衡对象如调节阀控制的流量；如右侧所示，积分过程没有平衡点，即控制器输出变化后过程在一个方向持续变化，除非进行新的干预否则积分过程将持续变化而无法达到新的稳态，典型的积分对象如液位。</p><p><img src="自衡对象和积分对象-8008603.png" alt="图2 自衡对象和积分对象" width="100%"></p><h3 id="线性系统的叠加原理">线性系统的叠加原理</h3><p>线性系统必须满足<strong>线性叠加性</strong>和<strong>线性齐次性</strong>。假设一系统对输入<span class="math inline">\(x_1(t)\)</span> 的响应输出为 <spanclass="math inline">\(y_1(t)\)</span>，对输入 <spanclass="math inline">\(x_2(t)\)</span> 的响应输出为 <spanclass="math inline">\(y_2(t)\)</span>。</p><p>（1）线性叠加性：线性系统对输入 <span class="math inline">\(x_1(t) +x_2(t)\)</span> 的响应输出一定是 <span class="math inline">\(y_1(t) +y_2(t)\)</span>。</p><p>（2）线性齐次性：线性系统对输入 <spanclass="math inline">\(ax_1(t)\)</span> 的响应输出一定是 <spanclass="math inline">\(ay_1(t)\)</span>。</p><p>（3）将（1）和（2）结合，即线性系统对输入 <spanclass="math inline">\(ax_1(t) + bx_2(t)\)</span> 的响应输出一定是 <spanclass="math inline">\(ay_1(t) + by_2(t)\)</span>。</p><h2 id="预测模型">预测模型</h2><p>在 DMC中，首先要对被控对象施加单位阶跃信号，来获得对象的单位阶跃响应。然后根据采样周期<span class="math inline">\(T\)</span> 来测定对象单位阶跃响应的采样值<span class="math inline">\(a_i = y(iT), \ i = 1, 2, 3, ...\)</span>，如图 3 左侧所示。对于渐近稳定的对象，阶跃响应在某一时刻 <spanclass="math inline">\(t=NT\)</span> 后将趋于平稳，以致 <spanclass="math inline">\(a_i(i&gt;N)\)</span> 与 <spanclass="math inline">\(a_N\)</span>的差已减小到与量化误差及测量误差有相同的数量级，因而可认为 <spanclass="math inline">\(a_N\)</span> 已近似等于阶跃响应在 <spanclass="math inline">\(t \rightarrow \infty\)</span> 时的稳态值 <spanclass="math inline">\(y_{\infty}\)</span>。这样，对象的动态信息就可近似地用有限集合<span class="math inline">\(\{a_1, a_2, a_3, ..., a_{N-1},a_N\}\)</span> 加以描述，这个集合的参数构成了 DMC的模型参数，这些参数也被称为<strong>动态系数</strong>，向量 $ = [a_1,a_2, a_3, ..., a_{N-1}, a_N]^T $称为<strong>模型向量</strong>，其中，<spanclass="math inline">\(N\)</span>被称为建模时域（模型时域长度）。</p><p><img src="阶跃信号和单位阶跃响应-8008603.png" alt="图3 单位阶跃信号和单位阶跃响应" width="100%"></p><p>如图 3 右侧所示，如果在 <span class="math inline">\(k\)</span>时刻，对被控对象施加一个阶跃信号 <span class="math inline">\(\Deltau(k)\)</span>，根据线性系统的叠加原理，可以预测系统在 <spanclass="math inline">\(\Delta u(k)\)</span>作用下未来时刻的输出为： <spanclass="math display">\[\begin{aligned}\tilde y_1(k+1\mid k) &amp;= \tilde y_0(k+1\mid k) + a_1 \Delta u(k) \\\tilde y_1(k+2\mid k) &amp;= \tilde y_0(k+2\mid k) + a_2 \Delta u(k) \\&amp; ... \\\tilde y_1(k+N\mid k) &amp;= \tilde y_0(k+N\mid k) + a_N \Delta u(k)\end{aligned}\tag{2}\]</span> 其中，<span class="math inline">\(\tilde y_0(k+1\mid k),\tilde y_0(k+2\mid k), ... ,\tilde y_0(k+N\mid k)\)</span> 是由 <spanclass="math inline">\(k\)</span>时刻以前其他控制量作用在系统上的系统响应，亦被称为初始预测值。把式（2）转化为向量形式为：<span class="math display">\[\pmb{\tilde y}_1(k) = \pmb{\tilde y}_0(k) + \pmb{a} \ \Delta{u(k)}\tag{3}\]</span> 其中，<span class="math inline">\(\pmb{\tilde y}_1(k) =[\tilde y_1(k+1\mid k), \tilde y_1(k+2\mid k), ..., \tilde y_1(k+N\midk)]^T\)</span>，<span class="math inline">\(\pmb{\tilde y}_0(k) =[\tilde y_0(k+1\mid k), \tilde y_0(k+2\mid k), ... ,\tilde y_0(k+N\midk)]^T\)</span>，<span class="math inline">\(\pmb{a}\)</span>为模型向量（动态系数），<spanclass="math inline">\(\Delta{u(k)}\)</span> 是在 <spanclass="math inline">\(k\)</span>时刻对系统施加的信号，其是一个标量。</p><p><img src="输入增量预测输出-8008603.png" alt="图4 输入增量预测输出" width="100%"></p><p>如图 4 所示，如果系统被施加的控制增量在 <spanclass="math inline">\(k\)</span> 时刻之后（含 <spanclass="math inline">\(k\)</span> 时刻）的 <spanclass="math inline">\(M\)</span> 个采样间隔都变化，为 <spanclass="math inline">\(\Delta{u(k)}, \Delta{u(k+1)}, ...,\Delta{u(k+M-1)}\)</span> ，则系统未来 <spanclass="math inline">\(P\)</span> 个时刻的预测模型输出为： <spanclass="math display">\[\begin{aligned}\tilde y_M(k+1\mid k) &amp;= \tilde y_0(k+1\mid k) + a_1 \Delta u(k) \\\tilde y_M(k+2\mid k) &amp;= \tilde y_0(k+2\mid k) + a_2 \Delta u(k) +a_1 \Delta u(k+1)\\&amp;... \\\tilde y_M(k+P\mid k) &amp;= \tilde y_0(k+P\mid k) + a_P \Delta u(k) +a_{P-1} \Delta u(k+1) + \ ... \ + a_{P-M+1} \Delta u(k+M-1)\end{aligned}\tag{4}\]</span> 式（4）可以合并整理为： <span class="math display">\[\tilde y_M(k+i\mid k) = \tilde  y_0(k+i\mid k) + \sum_{j=1}^{min(M, i)}a_{i-j+1} \Delta u(k+j-1) + , \ i=1,...,P\tag{5}\]</span> 转化为向量/矩阵形式为： <span class="math display">\[\pmb{\tilde y}_M(k) = \pmb{\tilde y}_0(k) + \pmb{A} \ \Delta{\pmb{u}(k)}\tag{6}\]</span> 即 <span class="math display">\[\begin{pmatrix}\tilde y_M(k+1\mid k) \\\tilde y_M(k+2\mid k) \\\vdots \\\tilde y_M(k+P\mid k)\end{pmatrix}_{P \times 1} =\begin{pmatrix}\tilde y_0(k+1\mid k) \\\tilde y_0(k+2\mid k) \\\vdots \\\tilde y_0(k+P\mid k)\end{pmatrix}_{P \times 1} +\begin{pmatrix}a_1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0\\a_2 &amp; a_1 &amp; 0 &amp; \cdots &amp; 0\\a_3 &amp; a_2 &amp; a_1 &amp; \cdots &amp; 0\\\vdots &amp; \vdots &amp; \vdots &amp;   &amp; \vdots\\a_P &amp; a_{P-1} &amp; a_{P-2} &amp; \cdots &amp; a_{P-M+1}\end{pmatrix}_{P \times M}\begin{pmatrix}\Delta u(k) \\\Delta u(k+1) \\\vdots \\\Delta u(k+M-1)\end{pmatrix}_{M \times 1}\]</span> 其中，<span class="math inline">\(\pmb A\)</span>被称为动态矩阵。<span class="math inline">\(M\)</span>为控制时域长度，<span class="math inline">\(P\)</span>为优化时域长度，通常 <span class="math inline">\(M\)</span> 和 <spanclass="math inline">\(P\)</span> 满足 <span class="math inline">\(M \leqP \leq N\)</span>。</p><h2 id="滚动优化">滚动优化</h2><p>DMC 是一种通过优化确定控制输入的算法。在每一时刻 <spanclass="math inline">\(k\)</span>，要确定从该时刻起的 <spanclass="math inline">\(M\)</span> 个控制增量 <spanclass="math inline">\(\Delta u(k), ..., \Delta u(k+M-1)\)</span>，使得在其作用下被控对象未来 <span class="math inline">\(P\)</span>个时刻的输出预测值 <span class="math inline">\(\tilde y_M(k+1\midk),...,\tilde y_M(k+P\mid k)\)</span> 尽可能地接近给定的期望 <spanclass="math inline">\(\omega(k+1),..., \omega(k+P)\)</span>，如下图所示。</p><p><img src="滚动优化-8008603.png" alt="图5 滚动优化" width="100%"></p><p>除了要求输出跟踪给定的期望值外，在控制过程中还希望控制增量 <spanclass="math inline">\(\Delta u\)</span>不要剧烈变化，这一因素可在优化性能指标中加入软约束予以考虑。因此，<spanclass="math inline">\(k\)</span>时刻的优化性能指标（优化目标函数）可取为： <span class="math display">\[minJ(k) = \sum_{i=1}^{P} q_i \ [\ \omega(k+i)-\tilde y_M(k+i\mid k) \]^2 + \sum_{j=1}^{M} r_j \ \Delta u^2(k+j-1)\tag{7}\]</span> 其中，<span class="math inline">\(q_i, r_j\)</span>是是权系数，它们分别表示对跟踪误差及控制量变化的抑制程度。当存在对控制量和输出量的约束时，该优化问题需结合约束条件求解，是一个典型的二次规划问题。如果不考虑约束的情况下，上述问题就是在动态模型式（6）约束下，以<span class="math inline">\(\Delta \pmb{u}(k) = [\Delta u(k), ...,\Delta u(k+M-1)]^T\)</span>为优化变量，使性能指标式（7）最小的优化问题。</p>式（7）可以改写成向量的形式： <span class="math display">\[\begin{aligned}minJ(k) &amp;= [\ \pmb{\omega}(k)- \pmb{\tilde y}_M(k) \ ]^T \ \pmb{Q} \[\ \pmb{\omega}(k)- \pmb{\tilde y}_M(k) \ ] + \pmb{\Delta u}^T(k)\\pmb{R}\ \pmb{\Delta u}(k) \\&amp;= ||\pmb{\omega}(k)- \pmb{\tilde y}_M(k)||^2_{\pmb{Q}} +||\pmb{\Delta u}(k)||^2_{\pmb{R}}\end{aligned}\tag{8}\]</span> 其中， $$<span class="math display">\[\begin{aligned}\pmb{\omega}(k) &amp;= [\ \omega(k+1), \omega(k+2),..., \omega(k+P) \]^T \\\\\pmb Q &amp;= diag(q_1, q_2, ..., q_P)= \begin{pmatrix}q_1 &amp; 0 &amp; \cdots &amp; 0\\0 &amp; q_2 &amp; \cdots &amp; 0\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\0 &amp; 0 &amp; \cdots &amp; q_P\end{pmatrix}_{P\times P} \\\\\pmb R &amp;= diag(r_1, r_2, ..., r_M)= \begin{pmatrix}r_1 &amp; 0 &amp; \cdots &amp; 0\\0 &amp; r_2 &amp; \cdots &amp; 0\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\0 &amp; 0 &amp; \cdots &amp; r_M\end{pmatrix}_{M\times M}\end{aligned}\]</span><p>$$ 由权系数构成的对角阵 <span class="math inline">\(Q, R\)</span>分别称为误差权矩阵和控制权矩阵。</p><p>将式（6）代入式（8），可得： <span class="math display">\[minJ(k) = ||\pmb{\omega}(k)- \pmb{\tilde y}_0(k) - \pmb A \\Delta{\pmb{u}(k)}||^2_{\pmb{Q}} + ||\pmb{\Delta u}(k)||^2_{\pmb{R}}\tag{9}\]</span> 在 <span class="math inline">\(k\)</span> 时刻，<spanclass="math inline">\(\pmb{\omega}(k), \pmb{\tilde y}_0(k)\)</span>均为已知，使 <span class="math inline">\(J(k)\)</span> 取极小的 <spanclass="math inline">\(\pmb{\Delta u}(k)\)</span> 可通过极值必要条件<span class="math inline">\(\frac{dJ(k)}{d \pmb{\Delta u}(k)} =0\)</span> 求得 <span class="math display">\[\pmb{\Delta u}(k) = (\pmb{A}^T \pmb{Q} \pmb{A} + \pmb{R})^{-1} \pmb{A}^T\pmb{Q} [\ \pmb{\omega}(k)- \pmb{\tilde y}_0(k) \ ]\tag{10}\]</span></p><blockquote><ul><li>证明式（10）：（二次型的求导）</li></ul><p><span class="math display">\[\begin{aligned}&amp;\quad \quad \quad \quad \quad \quad \quad \quad \quad\frac{dJ(k)}{d \pmb{\Delta u}(k)} = 0 \\&amp;\Rightarrow - 2 \pmb{A}^T \pmb{Q} [\ \pmb{\omega}(k)- \pmb{\tildey}_0(k) - \pmb A \ \Delta{\pmb{u}(k)} \ ] + 2 \pmb{R} \ \pmb{\Deltau}(k) = 0 \\&amp;\Rightarrow 2(\pmb{A}^T \pmb{Q} \pmb{A} + \pmb{R}) \pmb{\Deltau}(k) = 2 \pmb{A}^T \pmb{Q} [\ \pmb{\omega}(k)- \pmb{\tilde y}_0(k) \]\\&amp;\Rightarrow \pmb{\Delta u}(k) = (\pmb{A}^T \pmb{Q} \pmb{A} +\pmb{R})^{-1} \pmb{A}^T \pmb{Q} [\ \pmb{\omega}(k)- \pmb{\tilde y}_0(k)\ ]\end{aligned}\]</span></p></blockquote><p>公式（10）给出了 <span class="math inline">\(k\)</span>时刻优化所得到的 <span class="math inline">\(\Delta u(k), ..., \Deltau(k+M-1)\)</span> 的最优值。<u>但 DMC并不把它们全部实施，而只是取其中的即时控制增量 <spanclass="math inline">\(\Delta u(k)\)</span> 构成实际控制作用于对象。</u><span class="math inline">\(\Delta u(k)\)</span> 是 <spanclass="math inline">\(\pmb{\Delta u}(k)\)</span>的第一个元素，它可以表示为： <span class="math display">\[\Delta u(k) = \pmb{c}^T \pmb{\Delta u}(k) = \pmb{d}^T [\\pmb{\omega}(k)- \pmb{\tilde y}_0(k) \ ]\tag{11}\]</span> 其中，<span class="math inline">\(M\)</span> 维行向量 <spanclass="math inline">\(\pmb{c}^T = [\ 1 \ 0 \ ... \ 0 \ ]\)</span>表示取后续矩阵中首行的运算，<span class="math inline">\(P\)</span>维行向量 <span class="math display">\[\pmb{d}^T = \pmb{c}^T (\pmb{A}^T \pmb{Q} \pmb{A} + \pmb{R})^{-1}\pmb{A}^T \pmb{Q} \triangleq [\ d_1 \  ... \ d_p \ ]\tag{12}\]</span></p><blockquote><ul><li><span class="math inline">\(x \triangleq y\)</span> 读作 <spanclass="math inline">\(x\)</span> 定义为 <spanclass="math inline">\(y\)</span> 。</li></ul></blockquote><p>称为控制向量。一旦优化策略确定（即 <spanclass="math inline">\(P,M,Q,R\)</span> 确定），则 <spanclass="math inline">\(\pmb{d}^T\)</span>可由式（12）一次离线算出。式（11）就是DMC在无约束情况下控制律的解析式。这样，优化问题的在线求解就简化为直接计算控制律式（11），这是十分简易的。<u>需强调的是，一旦在优化问题中考虑了系统存在的输入输出约束，则其解便不能以上述解析形式（10）给出，也得不到控制律的解析式（11）。</u></p><p>在求出控制增量 <span class="math inline">\(\Delta u(k)\)</span>后，实际控制量为:</p><p><span class="math display">\[u(k) = u(k-1) + \Delta u(k)\tag{13}\]</span></p><p>将 <span class="math inline">\(u(k)\)</span>作用于对象，到下一时刻，又以 <span class="math inline">\(k+1\)</span>取代 <span class="math inline">\(k\)</span> 提出同样的优化问题求出 <spanclass="math inline">\(\Delta u(k+1)\)</span>，得到 <spanclass="math inline">\(u(k+1)\)</span> 作用于对象。如此滚动进行，这就是“滚动优化” 的含义。</p><h2 id="反馈校正">反馈校正</h2><p>当 <span class="math inline">\(k\)</span> 时刻把控制 <spanclass="math inline">\(u(k)\)</span>实施于对象时，相当于在对象输入端加上了一个幅值为 $ u(k) $的阶跃，利用预测模型公式（2），可算出在其作用下未来时刻的输出预测值：<span class="math display">\[\pmb{\tilde y}_{N1}(k) = \pmb{\tilde y}_{N0}(k) + \pmb{a} \ \Delta{u(k)}\tag{14}\]</span>它为公式（2）的向量形式，由于在实际中存在模型失配、环境干扰等未知因素，由式（14）给出的预测值有可能偏离实际值，若不及时利用实时信息进行反馈校正，下一步的优化将建立在不准确的模型预测基础上，随着过程的进行，预测输出有可能越来越偏离实际输出。为了防止只依赖模型的开环优化所造成的误差，DMC在 <span class="math inline">\(k+1\)</span>时刻计算优化控制量前，需先检测对象的实际输出 <spanclass="math inline">\(y(k+1)\)</span>，并把它与由式（14）给出的模型预测的该时刻输出<span class="math inline">\(\tilde y_1(k+1\mid k)\)</span>相比较，构成输出误差 <span class="math display">\[e(k+1) = y(k+1) - \tilde y_1(k+1\mid k)\tag{15}\]</span>这一误差信息反映了模型中未包括的不确定因素对输出的影响，可用来预测未来的输出误差，用以补充基于模型的预测。由于对误差的产生缺乏因果性的描述，故误差预测只能采用启发式的方法，例如，可采用对<span class="math inline">\(e(k+1)\)</span>加权的方式修正对未来输出的预测 <span class="math display">\[\pmb{\tilde y}_{cor}(k+1) = \pmb{\tilde y}_{N1}(k) + \pmb{h} \ e(k+1)\tag{16}\]</span> 其中， <span class="math display">\[\pmb{\tilde y}_{cor}(k+1) =\left[\begin{matrix}\tilde y_{cor}(k+1|k+1)\\\tilde y_{cor}(k+2|k+1)\\\vdots\\\tilde y_{cor}(k+N|k+1)\end{matrix}\right]\]</span> 为校正后的输出预测向量，由权系数组成的 <spanclass="math inline">\(N\)</span> 维向量 <spanclass="math inline">\(\pmb{h} = [h_1, h_2, \ ...,\h_N]^T\)</span>称为校正向量。</p><p>在 <span class="math inline">\(k+1\)</span>时刻，由于时间基点的变动，预测的未来时间点也将移到 <spanclass="math inline">\(k+2, k+3, \ ..., \ k+N+1\)</span>，因此，<spanclass="math inline">\(\pmb{\tilde y}_{cor}(k+1)\)</span>的元素还需通过移位才能构成 <span class="math inline">\(k+1\)</span>时刻的初始预测值 <span class="math display">\[\tilde y_{0}(k+1+i|k+1) = \tilde y_{cor}(k+1+i|k+1), \ i=1,2,...,N-1\tag{17}\]</span> 而由于模型的截断，在 <span class="math inline">\(k\)</span>时刻预测中没有的 <span class="math inline">\(\tildey_{cor}(k+1+N|k+1)\)</span>，可由 <span class="math inline">\(\tildey_{cor}(k+N|k+1)\)</span>近似。这一通过移位对 <spanclass="math inline">\(k+1\)</span> 刻初始预测值的设置可用向量形式表示为<span class="math display">\[\pmb{\tilde y}_{N0}(k+1) = \pmb{S} \ \pmb{\tilde y}_{cor}(k+1)\tag{18}\]</span> 其中，移位阵 <span class="math inline">\(\pmb{S}\)</span>定义为 <span class="math display">\[\pmb{S} =\left[\begin{matrix}0&amp;1&amp; &amp;0\\\vdots&amp;\ddots&amp;\ddots&amp;\\\vdots&amp; &amp;0&amp;1\\0&amp;\cdots&amp;0&amp;1\end{matrix}\right]\]</span> 有了 <span class="math inline">\(\pmb{\tildey}_{N0}(k+1)\)</span>，可像上面那样进行 <spanclass="math inline">\(k+1\)</span>刻的优化计算，求出 <spanclass="math inline">\(\Delta{u(k+1)}\)</span>。整个控制过程就是以这种结合反馈校正的滚动优化方式反复在线进行的。</p><h2 id="dmc-算法结构">DMC 算法结构</h2><p><img src="动态矩阵控制的算法结构-8008603.png" alt="图6 动态矩阵控制的算法结构" width="100%"></p><p>如图 6 所示，DMC算法是由预测、控制、校正3部分构成的。图中粗箭头表示向量流，细箭头表示纯量流。在每一采样时刻，未来<span class="math inline">\(P\)</span> 个时刻的期望输出 <spanclass="math inline">\(\pmb{w}_P(k)\)</span> 与初始预测输出 <spanclass="math inline">\(\pmb{\tilde y}_{P0}(k)\)</span>构成的偏差向量与动态控制向量 <spanclass="math inline">\(\pmb{d}^T\)</span>点乘（如式（11）所示），得到该时刻的控制增量 <spanclass="math inline">\(\Deltau(k)\)</span>。这一控制增量一方面通过数字积分（累加）运算求出控制量<span class="math inline">\(u(k)\)</span>（如式（13）所示）并作用于对象，另一方面与模型向量 <spanclass="math inline">\(\pmb{a}\)</span> 相乘，并按照公式（14）计算出在其作用后的预测输出 <span class="math inline">\(\pmb{\tildey}_{N1}(k)\)</span>。到下一采样时刻，首先检测对象的实际输出 <spanclass="math inline">\(y(k+1)\)</span>，并与预测值 <spanclass="math inline">\(\tilde y_1(k+1\mid k)\)</span>（<spanclass="math inline">\(\pmb{\tilde y}_{N1}(k)\)</span>的第一项）相比较后按公式（15）计算出偏差 <spanclass="math inline">\(e(k+1)\)</span>。这一误差与校正向量 <spanclass="math inline">\(\pmb{h}\)</span>相乘作为误差预测，再加入到模型预测中按式（16）得到校正后的预测输出 <spanclass="math inline">\(\pmb{\tildey}_{cor}(k+1)\)</span>，并按式（18）移位后作为新的初始预测值 <spanclass="math inline">\(\pmb{\tilde y}_{N0}(k+1)\)</span>。图中 <spanclass="math inline">\(z^{-1}\)</span>表示时间基点的记号后推一步，这样等于把新的时刻重新定义为 <spanclass="math inline">\(k\)</span> 时刻。整个过程将反复在线进行。</p><h2 id="dmc-算法实现">DMC 算法实现</h2><p>无约束的DMC算法需要离线准备3组参数，即模型向量、控制向量和校正向量的参数，它们的来源分别如下：</p><p>（1）模型参数 <span class="math inline">\(\{a_i\}\)</span>可通过检测对象的单位阶跃响应并经光滑后得到。在这里需要强调的是，应尽可能滤除测量数据中的噪声和干扰，使得到的模型具有光滑的动态响应，否则会影响控制质量甚至造成不稳定。</p><p>（2）控制系数 <span class="math inline">\(\{d_i\}\)</span>是根据式（12）算出的，其中要用到模型参数 <spanclass="math inline">\({a_i}\)</span>，而反映优化策略的参数 <spanclass="math inline">\(\pmb{P}\)</span> 、<spanclass="math inline">\(\pmb{M}\)</span>、<spanclass="math inline">\(\pmb{Q}\)</span>、<spanclass="math inline">\(\pmb{R}\)</span>需要利用仿真程序进行整定后确定。</p><p>（3）校正系数 <span class="math inline">\(\{h_i\}\)</span>与上述两组参数均无关，可自由选择。</p><p>这 3 组动态系数确定后，应置入固定的内存单元，以便实时调用。</p><p><img src="无约束动态矩阵控制的在线计算流程-8008603.png" alt="图7 无约束动态矩阵控制的在线计算流程" width="60%"></p><p>DMC的在线计算由初始化模块与实时控制模块组成。初始化模块是在投入运行的第 1步，先检测对象的实际输出 <span class="math inline">\(y(k)\)</span>并把它设定为输出预测初值 <span class="math inline">\(\tilde y_0(k+i\midk), i=1,2,...,N\)</span>。从第 2步起即转入实时控制模块，在每一采样时刻的在线计算流程如图 7所示，其中对未来输出的预测值只需设置一个 <spanclass="math inline">\(N\)</span> 维数组 <spanclass="math inline">\(y(i)\)</span>，流程图中的算式依次对应于式（15）、式（16）、式（17）、式（11）、式（13）和式（14）。注意在该流程图中设定值<span class="math inline">\(\pmb{w}\)</span>是定值并事先置入内存。若需跟踪时变的轨线，则还应编制一个设定值模块，在线计算每一时刻优化时域内的输出期望值<span class="math inline">\(w(i),i=1,2,...,P\)</span>，并以此代替流程图中的 <spanclass="math inline">\(\pmb{w}\)</span>。</p><p>需要指出的是，对于无约束 DMC算法，由于优化问题具有解析解，在线优化已直接隐含在优化的结果式（11）中，因此在线计算只需要<span class="math inline">\(\{a_i\}\)</span>、 <spanclass="math inline">\(\{d_i\}\)</span> 、<spanclass="math inline">\(\{h_i\}\)</span> 3组参数，不存在显式的优化求解过程。但对于有约束的DMC算法，控制增量 <spanclass="math inline">\(\Delta u(k)\)</span>需通过二次规划算法求得，不再有式（11）的解析解，这时要改用二次规划算法模块取代流程图中计算控制增量的解析表达式（11）。由于此时不存在控制向量<spanclass="math inline">\(\pmb{d}^T\)</span>，离线只需确定模型参数和校正参数。</p><h2 id="参考">参考</h2><p>[1] 席裕庚. 预测控制 (第 2 版) [M]. 北京: 国防工业出版社, 2013(12):10-16.</p>]]></content>
    
    
    <categories>
      
      <category>控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>火电工艺</title>
    <link href="/2025/09/10/%E7%81%AB%E7%94%B5%E5%B7%A5%E8%89%BA/"/>
    <url>/2025/09/10/%E7%81%AB%E7%94%B5%E5%B7%A5%E8%89%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="火电工艺流程图.png" alt="图1 亚临界汽包炉火电机组工艺流程图" width="100%"></p><h2 id="火力发电厂的基本生产过程">火力发电厂的基本生产过程</h2><p>作为原料的燃煤由制粉系统研磨成很细的煤粉，煤粉和加热后的空气一起被送往锅炉炉膛，煤粉在炉膛中剧烈燃烧，并释放出大量的热量，这些热量将锅炉受热面内压力很高的水反复加热，直至达到500多摄氏度的高温蒸汽，高温高压蒸汽通过管道进入汽轮机的汽缸，推动汽轮机的转子高速旋转，发电机的转子与汽轮机的转子同轴连接，在汽轮机的驱动下随汽轮机同步旋转，旋转的转子磁场切割定子绕组，从而使发电机定子绕组中产生感应电动势，发电机产生的电能通过升压变压器、输电线路向电网输送，在汽轮机中做完功的蒸汽温度和压力降至很低，它们被排入凝汽器内放出余热并凝结成水，经加热器加热和水泵升压后再送到锅炉，汽水如此往复，不断循环。</p><h2 id="锅炉设备">锅炉设备</h2><p>锅炉设备是火电厂的主要设备之一，是生产蒸汽的庞大而复杂的热交换设备。它的作用是将一定数量的燃料燃烧，并将燃烧释放的热量传递给水，使水加热、汽化并过热成一定压力和温度的主蒸汽。锅炉设备可分5部分：（1）<strong>锅炉本体</strong>；（2）<strong>输煤系统</strong>；（3）<strong>制粉系统</strong>；（4）<strong>烟风及燃烧系统</strong>；（5）<strong>除尘及排渣系统</strong>。</p><p><img src="锅炉设备组成示意图.png" alt="图2 锅炉设备组成示意图" width="80%"></p><h3 id="锅炉本体">锅炉本体</h3><p>锅炉本体包括<strong>炉膛、烟道、省煤器、汽包、下降管、水冷壁、过热器、再热器、燃烧器、空气预热器</strong>。其中省煤器、水冷壁、过热器、再热器、空气预热器称为<strong>锅炉的受热面</strong>，他们都是由许多金属管子组成的金属束。</p><p><img src="锅炉本体示意图.png" alt="图3 锅炉本体示意图" width="80%"></p><p>如图 1所示，红线表示蒸汽，蓝线表示水来示意锅炉里面的汽水流动，具有一定压力的水首先进入锅炉的省煤器，吸收来自烟道里烟气释放的热量，然后进入锅炉的汽包，水再沿着下降管进入到布置在锅炉四周的水冷壁，水在这里受热后开始汽化并产生蒸汽，所形成的汽水混合物自然上升，又回到汽包。汽包将汽和水分离，分离出的水又重新沿下降管返回到水冷壁中吸热、汽化。汽包中分离出的蒸汽则进入过热器进一步加热使其温度升高，形成高温高压的饱和蒸汽，最后送至汽轮机做功。</p><p><img src="锅炉类型.png" alt="图4 锅炉类型" width="80%"></p><p>从过热器出来进入汽轮机的蒸汽称为主蒸汽，300 MW 机组的主蒸汽高达 16MPa，约 160 个大气压以上，温度高达 530 ℃以上。在汽轮机中做过一部分功的蒸汽，其温度和压力都有所下降，需要将这些蒸汽又送回到锅炉的再热器中进行再次加热。在温度达到530 ℃以后，再次送入汽轮机中继续做功，蒸汽返回锅炉进行再热的目的主要是提高机组的效率。做完功的蒸汽被凝结成水后返回到锅炉。这种形式的锅炉称为<strong>自然循环锅炉</strong>，其特点是水在水冷壁中不断汽化产生蒸汽时，因为汽水混合物的密度比水要小，它会自然上升进入汽包，而汽水分离后的水会自然经下降管进入到水冷壁，因此这种循环型式叫做自然循环。</p><p>当主蒸汽压力更高时，汽水的密度相差较小，就必须采用强制循环泵产生的动力使工质在水冷壁中流动，这种锅炉称为<strong>强制循环锅炉</strong>。当主蒸汽压力再进一步提高时，例如600 MW这样的高参数机组，就必须采用所谓的<strong>直流锅炉</strong>。这种锅炉不设汽包，工质是一次通过水冷壁，水冷壁出口已全部是蒸汽，因而也就不存在循环。</p><h3 id="输煤系统">输煤系统</h3><p>原煤一般可由火车、轮船和汽车等运至电厂，其中以火车运煤最为普遍。卸煤机械有多种形式，其中自动化程度最高的是翻车机。卸煤时，先将载煤列车解列，翻车机将整节煤车翻转180°，将煤卸到地下的受煤斗中，卸下的煤再由胶带给煤机送到转运站，转运站可直接将煤送到锅炉房或煤场储存。煤场存煤可保证电厂5～15天的耗煤量。有的火电厂还设有混煤罐用于混配不同的煤种，以保证锅炉的正常燃烧，同时混煤罐还有储煤的作用。原煤通过一系列输煤栈桥被送往锅炉房，输煤栈桥内装有皮带输送机，原煤在输送途中首先要经过电磁除铁器，除去其中的铁件，还要经过碎煤机将较大的煤块儿破碎，最后将不含杂质的煤送往制粉系统。</p><h3 id="制粉系统">制粉系统</h3><p>作为大型锅炉燃料的原煤都必须研磨成很细的煤粉才能送到锅炉燃烧，完成这一任务的是制粉系统，制粉系统位于汽轮机车间和锅炉之间。制粉系统分为两种：（1）中间储藏式干燥剂送粉制粉系统（中储式制粉系统）；（2）直吹式制粉系统。</p><h4 id="中储式制粉系统">中储式制粉系统</h4><p><img src="中储式制粉系统.png" alt="图5 中储式制粉系统" width="100%"></p><p>由输煤系统将原煤送到锅炉房的原煤仓中，再由给煤机送入磨煤机，在其中研磨成煤粉。同时，经空气预热器加热的热风也进入到磨煤机，进入磨煤机的热风既可用来输送煤粉，还可对要研磨的煤起到加热干燥的作用，故称为干燥剂。磨制好的煤首先由热风送到粗粉分离器，在那里将不合格的煤粉分离出来，送到磨煤机再进行研磨。合格的煤粉则进入旋风分离器，旋风分离器也称为细粉分离器，它将空气和煤粉分离，分离出来的煤粉进入煤粉仓，分离出来的空气中仍含有少量煤粉，这部分空气称为乏气，再由排粉机抽出。煤粉仓中的煤粉再由给粉机根据锅炉负荷的需要控制输出量，排粉机出来的乏气将煤粉通过燃烧器推入炉膛燃烧。这种将煤粉送入炉膛燃烧的热风称为一次风，有的锅炉的一次风不是用旋风分离器分离出来的乏气，而是直接通过专门的一次风机将空气预热器出口的热风与煤粉混合，而旋风分离器分离出来的乏气则单独送入炉膛，这种中间储仓式制粉系统因为有煤粉仓的缓冲作用，系统工作不受锅炉负荷的影响，调节也比较灵敏。</p><h4 id="直吹式制粉系统">直吹式制粉系统</h4><p><img src="直吹式制粉系统.png" alt="图6 直吹式制粉系统" width="80%"></p><p>直吹式制粉系统，它与中间储藏式制粉系统的不同之处在于不设煤粉仓，制出的煤粉直接送入锅炉，它具有系统简单，投资小的优点，但是煤粉量的调节比较困难。</p><h3 id="风烟及燃烧系统">风烟及燃烧系统</h3><p><img src="风烟流程示意图.png" alt="图7 风烟流程示意图" width="80%"></p><p>送风机从环境中吸入空气，然后送入空气预热器中加热，加热后的热风一部分去磨煤机，另一部分被称为二次风则直接进入炉膛去帮助燃烧。</p><p>煤粉悬浮在炉膛内燃烧，燃烧中心的温度可达 1500 ℃以上。燃烧时，大量的热量传给水冷壁里的水。燃烧形成的高温烟气沿着烟道依次冲刷过热器、再热器、省煤器、空气预热器等受热面。不断将热量传递给蒸汽，水和空气，而自身温度逐渐降低。烟气到达烟道尾部时大约在130 ℃左右。在引风机的作用下，烟气流入除尘器进行除尘净化，最后经烟囱排到大气。</p><h3 id="除尘排渣系统">除尘排渣系统</h3><p>火电厂对环境的污染主要是随炉烟排出的飞灰粉尘和有害气体，一般采用除尘器和较高的烟囱来减轻污染。静电除尘器利用高压电厂产生的静电来除尘，它可除去烟气中99 % 的粉尘。</p><p>炉内煤粉燃烧后的炉渣由捞渣机从炉底捞出并冲入地沟，再流至灰渣泵房。灰渣泵房利用管道将灰渣送至灰厂。除尘器出来的灰可以通过灰渣房再送至灰厂，也可通过气力输送管道或车辆送到灰渣利用单位。</p><h2 id="汽轮机设备">汽轮机设备</h2><h2 id="热力系统及其辅助设备">热力系统及其辅助设备</h2><p>汽轮机本体与锅炉本体之间由各种汽水管道，阀门及其辅助设备连成一个整体。这个整体便组成了发电厂的热力系统。热力系统除了要保证机组安全经济可靠的运行外，还要考虑机组能顺利启动、停机、切换设备和升降负荷等。因此热力系统，特别是大型机组的热力系统是相当复杂的。</p><p><img src="热力系统示意图.png" alt="图8 热力系统示意图" width="80%"></p><p>图 8是热力系统的示意图，热力系统的基本流程是这样的：来自锅炉的主蒸汽首先在汽轮机的高压缸里做功，从高压缸排出后又送入锅炉再热器中再加热，加热后的蒸汽又送入中压缸和低压缸中继续做功。最后汽轮机的排气进入凝汽器，凝汽器管束里侧通有来自环境的冷却水，排气在管束外侧流过时，不断放出余热，并凝结成水，冷却水将吸收的热量排入环境。从凝汽器排出的水称为主凝结水，为了提高机组的效率，主凝结水并不直接送到锅炉中，而是经过一系列加热器加热后，再进入锅炉。加热器的热源来自从气缸的不同部位抽出的蒸汽，用他们给加热器中的水进行加热。主凝结水经过凝结水泵升压后进入深度除盐装置进行水质处理，然后依次流过轴封加热器和4个低压回热加热器，在那里吸收来自汽轮机抽气的热量。主凝结水温度从30 ℃ 左右不断升高，达到 140 ℃左右后进入除氧器。除氧器将主凝结水中溶解的氧气等气体除去，以免对设备和管道造成腐蚀。同时除氧器本身也是一个混合式加热器，也可对主凝结水进行加热。从除氧器下部水箱出来的水会送入给水泵，给水泵将水升到很高的压力。从给水泵出来的水称为主给水，主给水依次流过3个高压加热器，温度达到260 ℃左右后进入省煤器，进行下一轮的汽水循环。为了使用和管理上的方便，一般都将加热器进行了编号，高压加热器为1、2、3 号，除氧器为 4 号，低压加热器为 5、6、7、8 号。</p><p>热力系统，特别是大型机组的全面性热力系统很复杂，可以分为以下六个系统：（1）主蒸汽及汽轮机旁路系统；（2）凝汽系统；（3）低压加热器系统；（4）给水除氧系统；（5）高压加热器系统；（6）补充水系统。</p><h4 id="主蒸汽及汽轮机旁路系统">主蒸汽及汽轮机旁路系统</h4><p>锅炉与汽轮机之间的蒸汽管道与通往各用汽处的支管及附件称为发电厂主蒸汽系统。对于再热式机组，还包括再热蒸汽管道。</p><p><img src="主蒸汽系统.png" alt="图9 母管制和单元制主蒸汽系统" width="100%"></p><p>中小型机组的主蒸汽系统采用母管制，参数相同的几台锅炉的蒸汽都引到主蒸汽母管上，再由母管引至汽轮机。这种系统灵活性较好，事故时，机炉可通过阀门互相切换，还可用于汽轮机和锅炉数量不等的情况。大型机组，特别是再热机组的主蒸汽系统都采用单元制系统，其特点是各个锅炉和对应的汽轮机组成一个独立单元。</p><p><img src="汽轮机旁路系统.png" alt="图10 汽轮机旁路系统" width="80%"></p><p>大型再热机组通常还设有旁路系统。机组启动时，锅炉先点火投运，而汽轮机高压缸尚未进汽时，锅炉再热器中没有工质流过。为了防止再热器干烧，将主蒸汽减温减压后直接引入再热器。再热器出口的蒸汽又经过减温减压进入凝气器，这样整个汽水绕过了汽轮机形成了循环。主蒸汽不进入汽轮机高压缸而是经过降压减温后进入再热器的管路称为高压旁路，也称Ⅰ级旁路。再热器出来的蒸汽不进入汽轮机的中低压缸，而是经过降压减温后直接进入凝汽器的管路称为低压旁路，也称Ⅱ级旁路。旁路系统是利用减温减压器的减压阀来降低蒸汽压力，同时在减压阀后将温度较低的凝结水或给水直接喷进蒸汽中来降低其温度。除了保护再热器外，旁路系统的作用还有很多，其中一个重要的作用是在启动时，参与主蒸汽参数的调整，从而加快启动时间，改善启动条件。</p><h4 id="凝汽系统">凝汽系统</h4><p><img src="凝汽器设备图.png" alt="图11 凝汽器设备图" width="60%"></p><p>凝汽系统是指与凝汽器相关的管路与设备，主要有凝汽器，凝结水泵，抽气设备，冷却水设备等。凝汽器是吸收汽轮机排汽的余热，并将其凝结成水的设备。凝汽器内有规律的排列着冷却管，前侧设有前水室，前水室被隔成上下两部分，下为进水室，上为出水室，后部有后水室。水室及管束外有外壳，外壳上部有汽轮机排气的进汽口，下部有汇集凝结水的热水井。冷却水从进水室流进，沿着下部管束流向凝汽器后部的后水室，然后折返从上部管束流向出水室。汽轮机的排气从凝汽器的进气口进入，在管束外面放热逐步凝结成水，汇集到凝汽器下部的热水井中。由凝结水泵抽出升压后，进入低压加热器系统。大型机组的凝汽器设计成方箱形，安装在汽轮机低压缸的底部，紧接低压缸的排汽口。因为低压缸有两个排汽口，所以凝汽器也分成甲乙两侧。</p><p><img src="凝器系统.png" alt="图12 直流供水方式和循环供水方式凝器系统" width="100%"></p><p>汽轮机的排汽在凝汽器中的凝结需要大量的冷却水。冷却水也称循环水，其供水方式有两种：一种为<strong>直流供水方式</strong>，也叫开式供水；这种供水方式是循环水泵直接由江河的上游取水，由循环水泵送进凝汽器；冷却水在凝汽器吸热后从凝汽器的出水管排入江河的下游。循环水泵一般安装在靠近水源的水泵房内。另一种供水方式为<strong>循环供水方式</strong>，也叫闭式供水方式，这种供水方式是在缺乏水源或水源离电厂较远时采用。它必须有冷却塔，冷却水池，循环水泵等设施。循环水泵从这些冷却设施的给水井中给水，在凝汽器中吸收排气热量后，再送回冷却设施中。利用水蒸发降温原理使水降温后再送至凝汽器循环使用。</p><p>冷却塔塔身较高，且做成双曲线形，起到通风筒的作用。空气从塔身下部进入，自然上升，由凝汽器出来的冷却水从冷却塔淋水装置的上部淋下，目的是增加水和空气接触的面积和时间，冷却塔的下部是冷却水池。</p><h4 id="低压加热器系统">低压加热器系统</h4><p>从凝汽器热井排除的凝结水称为主凝结水，它首先被凝结水泵升压，经过深度除盐装置对水进行化学处理，然后进入轴封加热器，利用汽轮机的轴端漏气来加热，温度有所提高后再依次流过四个低压加热器。主凝结水的温度不断提高，最后进入除氧器。由于主凝结水的压力较低所以这里的加热器称为低压加热器。</p><p><img src="低压加热器系统.png" alt="图13 低压加热器系统" width="80%"></p><p>低压加热器从外观上分为立式和卧式两种。图 13给出了立式低压加热器的剖面示意图，被加热的凝结水都是从进水管经进水室进入受热面管内加热后从出水室流出。加热蒸汽进入加热器后，在导向板的作用下反复冲刷受热面，不断放出热量而凝结成水。这种在加热器内由蒸汽凝结成的水称为疏水。疏水的出路有两种方式，一种叫逐级自流，即疏水自动由本级加热器流入到气测压力较低的加热器或凝汽器中去。另一种出水方式是采用疏水泵，将疏水打入加热器的出口，将其与主凝结水混合。卧式加热器的原理与立式基本相同。</p><p>深度除盐装置的作用是利用离子交换树脂对水进行进一步的化学处理以提高水的品质。轴封加热器为保持它内部恒定的负压，专门设有2 台抽风机。卧式低压加热器位于汽轮机运行平台的一侧。300 MW 机组的 7、8号两个加热器合成一体安装在凝汽器的内部。低压加热器设有旁路装置，这样在加热器故障时可将该加热器切除。主凝结水经旁路直接进入下一级，而不至于使机组停运。</p><h4 id="给水除氧系统">给水除氧系统</h4><p>给水除氧系统的任务是将主凝结水中的氧气和其它气体除掉以免产生对设备的腐蚀，同时将主凝结水的压力和温度进一步提高。来自低压加热器的主凝结水进入除氧器，在除氧器内除氧并加热后进入给水泵。</p><p><img src="给水除氧系统.png" alt="图14 给水除氧系统" width="60%"></p><p>除氧器包括除氧头和除氧水箱两部分，其中除氧头为除氧和加热装置，水箱为储存除氧水的容器。主凝结水从除氧头的顶部进入除氧器，汽轮机的抽汽从除氧头的中部进入，蒸汽将水加热到沸腾状态，水中溶解的气体就会溢出。溢出的气体从除氧头的排气管中排出。除去气体的水落入水箱，再从水箱进入给水泵，给水泵的作用是为使给水获得较高的压力。给水泵多采用圆筒形多级离心泵，其出口压力可达20 MPa，即 200个大气压以上。为防止给水泵可能产生气蚀而损坏，大型机组均设置前置泵。从除氧水箱出来的水先经过转速较低的前置泵，然后再进入主给水泵。300MW以上的机组经常运行的给水泵采用专门的小型汽轮机驱动，而备用泵采用电动机驱动。对于200 MW及以下的运行及备用给水泵一般都采用电动机驱动。因电动机的转速不可调节，所以电动机和给水泵之间广泛采用液压耦合器来调节给水泵的转速，从而调节给水流量。</p><h4 id="高压加热器系统">高压加热器系统</h4><p><img src="高压加热器系统.png" alt="图15 高压加热器系统" width="80%"></p><p>来自给水泵的主给水依次流过 3 个高压加热器，将温度提高到 260 ℃左右，然后进入锅炉的省煤器。这比将温度很低的凝结水直接进入锅炉可明显提高机组的效率。高压加热器的基本原理和基本结构等都与低压加热器相似，只是因其被加热的主给水温度很高，故称为高压加热器。高压加热器的疏水都是逐级自流，最后汇入除氧器。</p><p>1 号高压加热器与除氧器布置在同一平台上，2号高压加热器和3号高压加热器布置在汽轮机运行平台的一侧。高压加热器也设有旁路保护装置，当任何一台高压加热器的管系发生泄露，致使高压加热器内水位超过极限值时，控制系统立即动作，关闭加热器进口水管，让给水经旁路直接进入锅炉。此时不影响锅炉给水，锅炉仍可运行，只是经济性有所降低。</p><h4 id="补充水系统">补充水系统</h4><p>机组运行过程中不可避免有汽水损失，因此要不断向系统补充质量合格的水。补充水必须经过一些列的处理才能保证其质量。</p><p>水要在化学水处理车间首先经过澄清、过滤除去杂质。再经过一系列离子交换器的处理，除掉水中的硬质盐类，成为合格的补充水。为便于除氧，调节水量，补充水一般从系统的凝汽器或除氧器补入。</p><h2 id="电气设备">电气设备</h2>]]></content>
    
    
    <categories>
      
      <category>火电</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工艺</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025年8月17日晚随笔</title>
    <link href="/2025/08/17/2025%E5%B9%B48%E6%9C%8817%E6%97%A5%E6%99%9A%E9%9A%8F%E7%AC%94/"/>
    <url>/2025/08/17/2025%E5%B9%B48%E6%9C%8817%E6%97%A5%E6%99%9A%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="18e25e91fd8ace6ea7a63b629093127b2236acd4751ab19cce7f252a9bbac252">529bc8f933033e58292bc8056b5ce8ee585adeba23137249d9c5f2a0766003f699f371c8b60849660850da94211ba9dc6aa904ada4a9f08655fbea582dc77e735e1e019fad6d15f49ae79e6fb7e3ed1afb00a151d21cca8918c7c753c945f6e6098447f21a727e6000c3d506782407f90ae3a63d059a4964ebc23cb9dc3d99a3f7d5acbf7f9a636e959d66ad75846da78045f4a59a238191f456263c260e35d67ba61994a2a64cbe16c1f77fff4541cc7177cc5dfb7affe92fa43efc4d00f8abae1ebfcd76c0cfa4bf3a07ad6707a858</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">My Girl</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态时间规整</title>
    <link href="/2025/08/17/%E5%8A%A8%E6%80%81%E6%97%B6%E9%97%B4%E8%A7%84%E6%95%B4/"/>
    <url>/2025/08/17/%E5%8A%A8%E6%80%81%E6%97%B6%E9%97%B4%E8%A7%84%E6%95%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="动态时间规整dtw">动态时间规整（DTW）</h2><h3 id="dtw-算法简介">DTW 算法简介</h3><p><strong>动态时间规整（Dynamic TimeWarping，DTW）</strong>是用于评估两个时间序列相似性的算法，它的核心是在计算两个时间序列相似性之前会先进行对齐。</p><p>假设有两个时序序列 <span class="math inline">\(\mathbf{x}=[x_0,x_1,..., x_{n-1}]\)</span>，<span class="math inline">\(\mathbf{y}=[y_0,y_1, ..., y_{m-1}]\)</span>，先假设这两个时间序列是等长的，即 <spanclass="math inline">\(n=m\)</span>。如果要计算它们的相似度，对于欧式距离（欧几里得距离，Euclideandistance）来说，可以表示为</p><p><span class="math display">\[d(\mathbf{x}, \mathbf{y}) = \sqrt{(x_0-y_0)^2 + (x_1-y_2)^2 + \ ... \  +(x_{n-1}-y_{m-1})^n}, \ \ n=m\tag{1}\]</span></p><p>而 DTW 是返回所有的时间对齐路径中最小的欧式距离，可以表示为</p><p><span class="math display">\[DTW(\mathbf{x}, \mathbf{y}) = \min\limits_{\pi \in\mathcal{A}(\mathbf{x}, \mathbf{y})} \sqrt{\sum_{(i,j) \in \pi}{d(x_i,y_j)^2}}\tag{2}\]</span></p><p>其中，<span class="math inline">\(\pi\)</span>表示对齐路径，是一个长度为 <span class="math inline">\(k\)</span>的索引对 <span class="math inline">\(\left( \ (i_0, j_0), \ ... \ ,(i_{k-1}, j_{k-1}) \ \right)\)</span>；<spanclass="math inline">\(\mathcal{A}(\mathbf{x}, \mathbf{y})\)</span>是是所有可接受对齐路径的集合；<span class="math inline">\(d(x_i,y_j)\)</span> 可以表示为 <span class="math inline">\(d(x_i, y_j) =\sqrt{(x_i-y_j)^2} =|x_i-y_j|\)</span>。一条路径若要被视为可接受路径，必须满足以下条件：</p><p>（1）时间序列的开始和结束要匹配在一起，即：</p><p>​ （a）<span class="math inline">\(\pi_0 = (0,0)\)</span></p><p>​ （b）<span class="math inline">\(\pi_{k-1} = (n-1, m-1)\)</span></p><p>（2）在路径中时序序列索引 <span class="math inline">\(i\)</span> 和<span class="math inline">\(j\)</span>应该满足单调递增，且至少出现一次，即：</p><p>​ （a）<span class="math inline">\(i_{q-1} \le i_{q} \le i_{q-1} +1\)</span></p><p>​ （b）<span class="math inline">\(j_{q-1} \le j_{q} \le j_{q-1} +1\)</span></p><p><img src="欧式距离与动态时间规整的区别.png" alt="图1 欧式距离与动态时间规整的区别" width="80%"></p><p>图 1可以明显看出欧氏距离（左）和动态时间规整（DTW，右）来计算两个时间序列之间的相似度的区别。图中灰线表示一个匹配关系或者说是对齐路径中的一个索引对<span class="math inline">\((i,j)\)</span>，所有的灰线就是一个对齐路径<span class="math inline">\(\pi\)</span>（在 DTW 中这个 <spanclass="math inline">\(\pi\)</span>也是最优，即满足最小欧式距离）。当然了左图中欧式距离的匹配关系是固定，始终保证垂直对应（同时刻对应），即满足<span class="math inline">\(i=j\)</span>。</p><h3 id="dtw-的矩阵形式">DTW 的矩阵形式</h3><p>DTW 路径可以用二进制矩阵表示，其中非零元素 1表示对应的时间序列元素是匹配的，和上面对齐路径中 <spanclass="math inline">\(\pi\)</span> 的一个索引对 <spanclass="math inline">\((i,j)\)</span> 是等价的。</p><p><span class="math display">\[(A_{\pi})_{i,j} =\begin{cases}1, &amp; if \ (i, j) \in \pi  \\0, &amp; otherwise\end{cases}\tag{3}\]</span></p><p><img src="动态时间扭曲路径表示为二进制矩阵形式.png" alt="图2 动态时间扭曲路径表示为二进制矩阵形式" width="80%"></p><p>图 2 左图中的灰色线表示一条对齐路径 <spanclass="math inline">\(\pi\)</span>，灰色点表示一个索引对 <spanclass="math inline">\((i,j)\)</span> ，在矩阵 <spanclass="math inline">\(A_{\pi}\)</span> 中灰色点为 1，其余为 0。</p><p>因此，动态时间规整可以写成矩阵之间点积的最小化：</p><p><span class="math display">\[DTW(\mathbf{x}, \mathbf{y}) = \min\limits_{\pi \in\mathcal{A}(\mathbf{x}, \mathbf{y})} \sqrt {&lt;A_{\pi}, D(x,y)&gt;}\tag{4}\]</span></p><p>其中，<span class="math inline">\(D(x,y)\)</span> 存储的为 <spanclass="math inline">\(d(x_i, y_j)^2\)</span>，其与式（2）是等价的。</p><h3 id="算法实现动态规划">算法实现（动态规划）</h3><p>虽然按照顺序找出所有的路径 <spanclass="math inline">\(\mathcal{A}(\mathbf{x}, \mathbf{y})\)</span>后计算最小值是困难的（共有 <spanclass="math inline">\(O(\frac{(3+2\sqrt{2})^2}{\sqrt{n}})\)</span>条路径，文章[1]给出，暂未证明），但幸运的是可以使用动态规划找到该优化问题的精确解。动态规划依赖于递归，即将给定问题的解与（更简单的）子问题的解联系起来。一旦知道了这种联系，动态规划方法就会通过递归求解所需的子问题并存储其解以供后续使用（从而避免多次重复计算子问题）来解决原始问题。其算法复杂度为<span class="math inline">\(O(nm)\)</span>。</p><p>假设有两个时序序列 <span class="math inline">\(\mathbf{x}=[x_1,x_2,..., x_{n}]\)</span>，<span class="math inline">\(\mathbf{y}=[y_1, y_2,..., y_{m}]\)</span>，计算 <span class="math inline">\(DTW(\mathbf{x},\mathbf{y})\)</span> 的伪代码可以表示为：</p><p><img src="DTW算法伪代码.png" width="70%"></p><p>此外，我们还可以找到最优路径 <spanclass="math inline">\(path\)</span>。</p><p><img src="DTW算法最优规整路径伪代码.png" width="70%"></p><h2 id="时间加权动态时间规整twdtw">时间加权动态时间规整（TWDTW）</h2><p><strong>时间加权动态时间规整（Time-Weighted Dynamic Time Warping，TWDTW）</strong>相较于动态时间规整的主要不同在于：动态时间规整计算两个匹配元素<span class="math inline">\((x_i, y_j)\)</span> 的距离为欧式距离，即</p><p><span class="math display">\[d(x_i, y_j) = \sqrt{(x_i-y_j)^2} = |x_i-y_j|\tag{5}\]</span></p><p>而时间加权动态时间规整计算两个匹配元素 <spanclass="math inline">\((x_i, y_j)\)</span> 的距离（惩罚）公式为：</p><p><span class="math display">\[c(x_i, y_j) = \sqrt{(1-\alpha)(i-j)^2+\alpha(x_i-y_j)^2}\tag{6}\]</span></p><h2 id="dtw-的应用">DTW 的应用</h2><p>文章 [2] 提到 DTW被设计用来评估两个时间序列相似性，其开始主要用于语音识别，后被用于许多领域：手写和在线签名匹配、手语识别和手势识别，数据挖掘与时间序列聚类（时间序列数据库检索）、计算机视觉与计算机动画、监视、蛋白质序列比对与化学工程、音乐和信号处理。但这里我们主要是介绍DTW 的变形—时间加权动态时间规整在寻找两个时间序列的时滞关系的应用。</p><h3 id="寻找两个时间序列的时滞关系">寻找两个时间序列的时滞关系</h3><p>假设有两个温度测点，分别位于蒸汽加热器管道入口处和出口处，我们采集它们的一段历史趋势可以构成两个时间序列<span class="math inline">\(T_1\)</span> 和 <spanclass="math inline">\(T_2\)</span>。为了方便阐述和简化计算，我们将采样间隔定位2 分钟，采集了这两个测点 1 个小时的数据，如图 3 所示：</p><p><img src="蒸汽加热器管道入口出口测点温度趋势图.png" alt="图3 蒸汽加热器管道入口出口测点温度趋势图" width="90%"></p><p>利用 TWDTW算法 我们可以获取它们的匹配关系。</p><p><img src="最优扭曲路径.png" alt="图4 最优扭曲路径" width="80%"></p><p><img src="蒸汽加热器管道入口出口测点时滞关系.png" alt="图5 蒸汽加热器管道入口出口测点时滞关系" width="90%"></p><h2 id="参考">参考</h2><p>[1] Romain Tavenard. An introduction to Dynamic Time Warping[EB/OL].2021. <ahref="https://rtavenar.github.io/blog/dtw.html">https://rtavenar.github.io/blog/dtw.html</a>.</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs latex">@misc&#123;tavenard.blog.dtw,<br>  author=&quot;Romain Tavenard&quot;,<br>  title=&quot;An introduction to Dynamic Time Warping&quot;,<br>  year=2021,<br>  howpublished=&quot;<span class="hljs-keyword">\url</span>&#123;<span class="hljs-link">https://rtavenar.github.io/blog/dtw.html</span>&#125;&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>[2] Senin, Pavel. Dynamic Time Warping Algorithm Review[R]. Honolulu,HI, USA, 2008.</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs latex">@techreport&#123;senin2008dtwReview,<br>  author      = &#123;Senin, Pavel&#125;,<br>  title       = &#123;Dynamic Time Warping Algorithm Review&#125;,<br>  institution = &#123;Department of Information and Computer Sciences, University of Hawaii at Manoa&#125;,<br>  number      = &#123;CSDL-08-04&#125;,<br>  address     = &#123;Honolulu, HI, USA&#125;,<br>  month       = dec,<br>  year        = &#123;2008&#125;,<br>  note        = &#123;[R]&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="附件">附件</h2><ol type="1"><li>文章中伪代码的 latex 代码</li></ol><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\documentclass</span>[a4paper,11pt]&#123;article&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;algorithm&#125; <br><span class="hljs-keyword">\usepackage</span>&#123;algpseudocode&#125; <br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-comment">% Algorithm 1: Dynamic Time Warping</span><br><span class="hljs-keyword">\begin</span>&#123;algorithm&#125;<br><span class="hljs-keyword">\caption</span>&#123;Dynamic Time Warping (DTW)&#125;<br><span class="hljs-keyword">\begin</span>&#123;algorithmic&#125;[1]<br>            <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>n <span class="hljs-keyword">\leftarrow</span> |<span class="hljs-keyword">\mathbf</span>&#123;x&#125;|<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>m <span class="hljs-keyword">\leftarrow</span> |<span class="hljs-keyword">\mathbf</span>&#123;y&#125;|<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>dtw[] <span class="hljs-keyword">\leftarrow</span> new <span class="hljs-keyword">\ </span>[n <span class="hljs-keyword">\times</span> m]<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>dtw(0,0) <span class="hljs-keyword">\leftarrow</span> 0<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\For</span> &#123;<span class="hljs-built_in">$</span>i=1,2,<span class="hljs-keyword">\ldots</span>,n<span class="hljs-built_in">$</span>&#125;<br>                <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>dtw(i, 1) <span class="hljs-keyword">\leftarrow</span> dtw(i-1, 1) + d(x<span class="hljs-built_in">_</span>i, y<span class="hljs-built_in">_</span>1)<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\EndFor</span><br>            <span class="hljs-keyword">\For</span> &#123;<span class="hljs-built_in">$</span>j=1,2,<span class="hljs-keyword">\ldots</span>,m<span class="hljs-built_in">$</span>&#125;<br>                <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>dtw(1, j) <span class="hljs-keyword">\leftarrow</span> dtw(1, j-1) + d(x<span class="hljs-built_in">_</span>1, y<span class="hljs-built_in">_</span>i)<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\EndFor</span><br>            <span class="hljs-keyword">\For</span> &#123;<span class="hljs-built_in">$</span>i=1,2,<span class="hljs-keyword">\ldots</span>,n<span class="hljs-built_in">$</span>&#125;<br>                <span class="hljs-keyword">\For</span> &#123;<span class="hljs-built_in">$</span>j=1,2,<span class="hljs-keyword">\ldots</span>,m<span class="hljs-built_in">$</span>&#125;<br>                    <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>dtw(i, j) <span class="hljs-keyword">\leftarrow</span> d(x<span class="hljs-built_in">_</span>i, y<span class="hljs-built_in">_</span>j) + min&#123;(dtw(i-1, j), dtw(i, j-1), dtw(i-1, j-1))&#125;<span class="hljs-built_in">$</span><br>                <span class="hljs-keyword">\EndFor</span><br>            <span class="hljs-keyword">\EndFor</span><br>            <span class="hljs-keyword">\State</span> return <span class="hljs-built_in">$</span>dtw<span class="hljs-built_in">$</span><br><span class="hljs-keyword">\end</span>&#123;algorithmic&#125; <br><span class="hljs-keyword">\end</span>&#123;algorithm&#125;<br><br><span class="hljs-comment">% Algorithm 2 Optimal Warping Path</span><br><span class="hljs-keyword">\begin</span>&#123;algorithm&#125;<br><span class="hljs-keyword">\caption</span>&#123;Optimal Warping Path (DTW)&#125;<br><span class="hljs-keyword">\begin</span>&#123;algorithmic&#125;[1]<br>            <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>path[] <span class="hljs-keyword">\leftarrow</span> new <span class="hljs-keyword">\ </span>array<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>i <span class="hljs-keyword">\leftarrow</span> rows(dtw)<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>j <span class="hljs-keyword">\leftarrow</span> columns(dtw)<span class="hljs-built_in">$</span><br>            <span class="hljs-keyword">\While</span>&#123;<span class="hljs-built_in">$</span>(i&gt;1) <span class="hljs-keyword">\&amp;</span> (j&gt;1)<span class="hljs-built_in">$</span>&#125;<br>                <span class="hljs-keyword">\If</span> &#123;<span class="hljs-built_in">$</span>i==1<span class="hljs-built_in">$</span>&#125;<br>                    <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>j=j-1<span class="hljs-built_in">$</span><br>                <span class="hljs-keyword">\ElsIf</span> &#123;<span class="hljs-built_in">$</span>j==1<span class="hljs-built_in">$</span>&#125;<br>                    <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>i=i-1<span class="hljs-built_in">$</span><br>                <span class="hljs-keyword">\Else</span><br>                    <span class="hljs-keyword">\If</span> &#123;<span class="hljs-built_in">$</span>dtw(i-1, j) == min&#123;(dtw(i-1, j), dtw(i, j-1), dtw(i-1, j-1))&#125;<span class="hljs-built_in">$</span>&#125;<br>                        <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>i=i-1<span class="hljs-built_in">$</span><br>                    <span class="hljs-keyword">\ElsIf</span> &#123;<span class="hljs-built_in">$</span>dtw(i, j-1) == min&#123;(dtw(i-1, j), dtw(i, j-1), dtw(i-1, j-1))&#125;<span class="hljs-built_in">$</span>&#125;<br>                        <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>j=j-1<span class="hljs-built_in">$</span><br>                    <span class="hljs-keyword">\Else</span><br>                        <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>i=i-1<span class="hljs-built_in">$</span><br>                        <span class="hljs-keyword">\State</span> <span class="hljs-built_in">$</span>j=j-1<span class="hljs-built_in">$</span><br>                    <span class="hljs-keyword">\EndIf</span><br>                    <span class="hljs-keyword">\State</span> path.add((i,j))<br>                <span class="hljs-keyword">\EndIf</span><br>            <span class="hljs-keyword">\EndWhile</span><br>            <span class="hljs-keyword">\State</span> return <span class="hljs-built_in">$</span>path<span class="hljs-built_in">$</span><br><span class="hljs-keyword">\end</span>&#123;algorithmic&#125; <br><span class="hljs-keyword">\end</span>&#123;algorithm&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>时间序列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PID 控制器</title>
    <link href="/2025/08/17/PID%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <url>/2025/08/17/PID%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="反馈回路">反馈回路</h2><p><img src="反馈控制系统.png" alt="图1 反馈控制系统" width="80%"></p><p>这是一个典型的反馈控制系统，其中：</p><table><thead><tr class="header"><th></th><th>含义</th><th>英文</th><th>举例（以一级喷水减温控制系统为例）</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(SP\)</span></td><td>设定值</td><td>Set Point</td><td>一级过热汽温设定值（一般由运行手操）</td></tr><tr class="even"><td><span class="math inline">\(PV\)</span></td><td>过程变量</td><td>Process Value</td><td>一级过热汽温测量值（测点一般选二级减温器前温度）</td></tr><tr class="odd"><td><span class="math inline">\(OP\)</span></td><td>控制器输出</td><td>Output</td><td>一级减温水阀门开度</td></tr><tr class="even"><td><span class="math inline">\(e(t)\)</span></td><td>偏差</td><td></td><td><span class="math inline">\(PV-SP\)</span></td></tr><tr class="odd"><td><span class="math inline">\(u(t)\)</span></td><td>被控对象输入</td><td></td><td>一级减温水流量</td></tr><tr class="even"><td><span class="math inline">\(y(t)\)</span></td><td>被控对象输出</td><td></td><td>一级过热汽温</td></tr><tr class="odd"><td><span class="math inline">\(d(t)\)</span></td><td>扰动</td><td></td><td>煤质、入炉煤含水率、炉膛吸热分布</td></tr></tbody></table><p>为了叙述方便，后文中 <span class="math inline">\(OP\)</span> 和 <spanclass="math inline">\(u(t)\)</span> 、<spanclass="math inline">\(PV\)</span> 和 <spanclass="math inline">\(y(t)\)</span> 是等价的。</p><h2 id="pid分类">PID分类</h2><p>PID有很多分类方式：可以根据时间域特性/实现方式分为<strong>连续型</strong>和<strong>离散型</strong>；可以根据控制器输出形式（控制量本身或者控制量的增量）来分为<strong>位置式</strong>和<strong>增量式</strong>；可以根据结构形式分为<strong>串联形式PID（交互式）</strong>、<strong>并联形式PID</strong>和<strong>标准形式PID（非交互式、ISA形式、理想形式）</strong>。</p><h3 id="连续型和离散型pid">连续型和离散型PID</h3><p>（1）连续型 <span class="math display">\[u(t) = K_P e(t) + K_I \int_0^te(t)dt + K_D \frac{de(t)}{dt}\tag{1}\]</span> （2）离散型 <span class="math display">\[u_k = K_Pe_k + K_I \sum_{j=0}^{k}e_j \cdot T + K_D \cdot\frac{e_k-e_{k-1}}{T}\tag{2}\]</span> 其中 <span class="math inline">\(T\)</span> 为采样时间。</p><h3 id="位置式和增量式pid">位置式和增量式PID</h3><p>（1）位置式 <span class="math display">\[u_k = K_Pe_k + K_I \sum_{j=0}^{k}e_j \cdot T + K_D \cdot\frac{e_k-e_{k-1}}{T}\tag{3}\]</span> 其中 <span class="math inline">\(T\)</span> 为采样时间。</p><p>（2）增量式 <span class="math display">\[\Delta{u_k} = K_P(e_k - e_{k-1}) + K_I e_k \cdot T + K_D \cdot\frac{e_k-2e_{k-1}+e_{k-2}}{T}\\u_k = u_{k-1} + \Delta{u_k}\tag{4}\]</span></p><p>（3）证明位置式与增量式等价</p><blockquote><p>【证明 1】： <span class="math display">\[\begin{aligned}\Delta{u_k} &amp;= u_k - u_{k-1} \\&amp;= K_Pe_k + K_I \sum_{j=0}^{k}e_j \cdot T + K_D \cdot\frac{e_k-e_{k-1}}{T} - (K_Pe_{k-1} + K_I \sum_{j=0}^{k-1}e_j \cdot T  +K_D \cdot \frac{e_{k-1}-e_{k-2}}{T}) \\&amp;= K_P(e_k - e_{k-1}) + K_I e_k \cdot T + K_D \cdot\frac{e_k-2e_{k-1}+e_{k-2}}{T}\end{aligned}\tag{5}\]</span></p></blockquote><blockquote><p>【证明 2】： <span class="math display">\[\begin{aligned}u_k &amp;= u_{k-1} + \Delta{u_k} \\&amp;= u_0 + \Delta{u_1} + \Delta{u_2} + ... + \Delta{u_k} \\&amp;= u_0 + K_p(e_k - e_0) + K_I \sum_{j=1}^{k}e_j \cdot T + K_D\frac{e_k-e_{k-1}-e_0+e_{-1}}{T}\end{aligned}\tag{6}\]</span></p></blockquote><h3 id="串行并行和标准型pid">串行、并行和标准型PID</h3><p>（1）串联形式PID</p><p><img src="串行PID结构图.png" alt="图2 串行PID结构图" width="80%"><span class="math display">\[u(t) = K_P \left[ \left( 1 + \frac{T_D}{T_I} \right) e(t) +\frac{1}{T_I} \int_0^t e(t) dt + T_D \frac{de(t)}{dt} \right]\tag{7}\]</span></p><p>（2）并联形式PID</p><p><img src="并行PID结构图.png" alt="图3 并行PID结构图" width="80%"><span class="math display">\[u(t) = K_P e(t) + K_I \int_0^te(t)dt + K_D \frac{de(t)}{dt}\tag{8}\]</span> 并行结构允许比例、积分和微分作用完全解耦，即 PID的三个参数都相互独立。</p><p>（3）标准形式PID</p><p><img src="理想型PID结构图.png" alt="图4 理想型PID结构图" width="80%"><span class="math display">\[\begin{align}u(t) &amp;= K_P \left[ e(t) + \frac{1}{T_I} \int_0^te(t)dt + T_D\frac{de(t)}{dt}\right] \\&amp;= K_P e(t) + \frac{K_P}{T_I} \int_0^te(t)dt + K_P T_D\frac{de(t)}{dt}\end{align}\tag{9}\]</span> 标准型结构中，修改 <span class="math inline">\(K_P\)</span>系数将影响比例、积分和微分作用。相较于并行结构，标准型的各参数有其明确的物理意义：</p><table><thead><tr class="header"><th></th><th><span class="math inline">\(K_P\)</span></th><th><span class="math inline">\(T_I\)</span></th><th><span class="math inline">\(T_D\)</span></th></tr></thead><tbody><tr class="odd"><td>名称</td><td>比例增益（Proportional Gain）</td><td>积分时间常数（Integral Time）</td><td>微分时间常数（Derivative Time）</td></tr><tr class="even"><td>物理意义</td><td>（1）决定当前误差 e(t) 对控制输出的影响强度;<br />（2）增大 <spanclass="math inline">\(K_P\)</span>，系统响应更快，纠正动作更激烈，但容易振荡；<br />（3）减小<spanclass="math inline">\(K_P\)</span>，系统响应变慢，稳态误差可能增大。</td><td>（1）积分项的时间基准，决定过去误差累积对控制输出的影响；<br />（2）积分项希望在误差持续存在的情况下不断“积累”，逐步将误差逼近0；<br />（3）积分作用越强（即<spanclass="math inline">\(T_I\)</span>越小），系统越快尝试消除稳态误差。</td><td>（1）预测未来误差趋势；<br />（2）用误差的变化率来提前做出反应；<br />（3）增大<spanclass="math inline">\(T_D\)</span>，系统会更敏感地对误差的变化速度做出反应（如防止超调），但太大容易放大噪声，系统变得不稳定。</td></tr><tr class="odd"><td>通俗理解</td><td><span class="math inline">\(K_P\)</span>决定了当前误差的重要性。</td><td>在理想条件下，如果误差维持不变，系统将在 <spanclass="math inline">\(T_I\)</span> 秒后将该误差完全消除。</td><td>预测如果当前误差增长趋势持续 <spanclass="math inline">\(T_D\)</span> 秒，将会出现多大误差，提前修正。</td></tr></tbody></table><blockquote><p><strong>解释一下为什么”在理想条件下，如果误差维持不变，系统将在 <spanclass="math inline">\(T_I\)</span> 秒后将该误差完全消除“？</strong></p><p>假设控制误差 <span class="math inline">\(e(t) = e_0\)</span>是一个不变的常数（比如由于一个阶跃扰动导致系统输出偏离设定值），初始控制器输出为0，被控对象是时不变系统（即在不同时间，对系统施加相同的 <spanclass="math inline">\(u(t)\)</span> ，系统输出 <spanclass="math inline">\(y(t)\)</span>不变），不考虑微分项，所以控制器的输出可以表示为： <spanclass="math display">\[\begin{align}u(t) &amp;= K_P \left[ e_0 + \frac{1}{T_I} \int_0^t e_0 dt \right] \\&amp;= K_P \left[ e_0 + \frac{1}{T_I} e_0 t \right] \\&amp;= K_P e_0 \left[ 1 + \frac{t}{T_I} \right]\end{align}\tag{10}\]</span> 由于 <span class="math inline">\(e_0\)</span> 是常数，所以<span class="math inline">\(u(t)\)</span>中比例部分是不变的（这也是为什么纯比例调节无法消除静态误差，因为对于时不变系统来时，施加相同的<span class="math inline">\(u(t)\)</span> ，系统输出 <spanclass="math inline">\(y(t)\)</span> 是不变，如果 <spanclass="math inline">\(u(t)\)</span> 那 <spanclass="math inline">\(y(t)\)</span>也不会变化，所以误差一直存在，即静态误差，或叫稳态误差），只有积分部分才影响<span class="math inline">\(u(t)\)</span> ，或者可以求一下上式的微分：<span class="math display">\[\frac{du(t)}{dt} = \frac{K_P}{T_I} \cdot e_0\tag{11}\]</span> 更加明显地看出只有积分部分才影响 <spanclass="math inline">\(u(t)\)</span>的变化，且是线性增加的（每个周期都增加 <spanclass="math inline">\(\frac{K_P}{T_I} \cdot e_0\)</span>），<spanclass="math inline">\(u(t)\)</span> 的变化会推动 <spanclass="math inline">\(y(t)\)</span> 靠近设定值，最终消除偏差。</p><p>先假设 <span class="math inline">\(\Delta y(t) = \frac{1}{K_P} \cdot\Delta u(t)\)</span>， 即当 <span class="math inline">\(u(t)\)</span>变化 <span class="math inline">\(\Delta u(t)\)</span> 时，<spanclass="math inline">\(y(t)\)</span> 就变化 <spanclass="math inline">\(\frac{1}{K_P} \cdot \Deltau(t)\)</span>（这里涉及了如何确定一个纯比例控制器的 <spanclass="math inline">\(K_P\)</span>值，后面讲调节方法的时候会再提及），那么如果想要消除误差 <spanclass="math inline">\(e_0\)</span>，就应该让 <spanclass="math inline">\(u(t)\)</span> 变化 <span class="math inline">\(K_Pe_0\)</span>，即 <span class="math inline">\(u(t+T) = u(t) + K_Pe_0\)</span>，前面已经说明了比例作用是不会让 <spanclass="math inline">\(u(t)\)</span> 变化的，所以其中 <spanclass="math inline">\(T\)</span> 就表明了积分作用需要 <spanclass="math inline">\(T\)</span> 时刻让 <spanclass="math inline">\(u(t)\)</span> 变化 <spanclass="math inline">\(e_0\)</span>，故现在只需要证明 <spanclass="math inline">\(T_I = T\)</span> 即可，证明如下： <spanclass="math display">\[\begin{align}&amp; u(t + T) - u(t) = K_P e_0 \\&amp;\implies K_P e_0 \left[ 1 + \frac{t+T}{T_I} \right] - K_P e_0\left[ 1 + \frac{t}{T_I} \right] = K_P e_0 \\&amp;\implies K_P e_0 \frac{T}{T_I} = K_P e_0 \\&amp;\implies T = T_I\end{align}\tag{12}\]</span></p><p>说明了系统将在 <span class="math inline">\(T_I\)</span> 秒后将误差<span class="math inline">\(e_0\)</span> 彻底消除，积分项在 <spanclass="math inline">\(T_I\)</span> 秒内就能产生与比例项相等的作用。</p></blockquote><h2 id="pid整定">PID整定</h2><h3id="pid控制器不同参数的阶跃响应分析">PID控制器不同参数的阶跃响应分析</h3><p><img src="PI控制器效果示意图.png" alt="图5 PI控制器效果示意图" width="90%"></p><p>图 5 显示了比例系数<spanclass="math inline">\(K_P\)</span>和积分时间<spanclass="math inline">\(T_I\)</span>的差异如何影响 PI控制器的响应。正中间的图形为基本情况，随着参数的整定，无论是翻倍还是减半，过程的每一个动态响应都截然不同。左上角的图显示，当比例作用加倍（比例系数加倍）且积分作用加倍（积分时间减半）时，控制器会产生大而缓慢的阻尼振荡。相反，右下角的图显示，当控制器比例作用减半（比例系数减半）且积分作用减半（积分时间加倍）时，响应变慢。</p><blockquote><p>比例作用和积分作用增强时，系统振荡；比例作用和积分作用减弱时，系统响应变慢。</p></blockquote><p><img src="纯比例控制比例增益不同时的设定中阶跃响应曲线.png" alt="图6 纯比例控制比例增益不同时的设定中阶跃响应曲线" width="80%"></p><p>比例系数 <span class="math inline">\(K_P\)</span>加大，使系统的动作灵敏，速度加快，振荡次数增多，调节时间变长。当比例系数太大时，系统会趋于不稳定。加大比例系数，在系统稳定的情况下，可以减小余差，提高控制精度，却不能完全消除余差（有余差，系统始终未达到1）。</p><p><img src="纯比例控制和比例积分控制阶跃响应曲线.png" alt="图7 纯比例控制和比例积分控制阶跃响应曲线" width="80%"></p><p>PI 控制器主要用来改善控制系统的稳态性能。因为单纯增大 P的方法减小余差的同时会使系统的超调量增大，破坏了系统的平稳性，而积分环节的引入可以与P 控制合作来消除上述的副作用。此外，引入积分作用可以消除余差。</p><p><img src="PID控制阶跃响应曲线.png" alt="图8 PID控制阶跃响应曲线" width="80%"></p><p>增加微分有利于加快系统的响应速度，使系统的超调量减小，稳定性增加，同时增大比例可以进一步加快系统的响应速度，使系统更快速。</p><h3 id="自衡对象和积分对象">自衡对象和积分对象</h3><p>工业过程中常见的过程有自衡和非自衡两种，下图显示了两个过程对输出阶跃变化的理想化趋势。左边的过程是非积分对象，也叫自衡对象；右边的过程是非自衡对象，也叫积分对象。如下图左侧所示，自衡对象能够响应控制器输出并逐渐达到新的稳态操作点，典型的自衡对象如调节阀控制的流量；如右侧所示，积分过程没有平衡点，即控制器输出变化后过程在一个方向持续变化，除非进行新的干预否则积分过程将持续变化而无法达到新的稳态，典型的积分对象如液位。</p><p><img src="自衡对象和积分对象.png" alt="图9 自衡对象和积分对象" width="100%"></p><h3 id="pid控制器正反作用判定">PID控制器正反作用判定</h3><p><img src="PID控制器.png" alt="图10 PID控制器" width="20%"></p><table><thead><tr class="header"><th></th><th>正作用</th><th>反作用</th></tr></thead><tbody><tr class="odd"><td>偏差计算</td><td><span class="math inline">\(e = PV-SP\)</span></td><td><span class="math inline">\(e = SP-PV\)</span></td></tr><tr class="even"><td><span class="math inline">\(PV\)</span>与<spanclass="math inline">\(OP\)</span>的关系</td><td><span class="math inline">\(PV\)</span>与<spanclass="math inline">\(OP\)</span>同向（<span class="math inline">\(PV\nearrow\)</span>，<span class="math inline">\(OP \nearrow\)</span>）</td><td><span class="math inline">\(PV\)</span>与<spanclass="math inline">\(OP\)</span>反向（<span class="math inline">\(PV\nearrow\)</span>，<span class="math inline">\(OP \searrow\)</span>）</td></tr><tr class="odd"><td>控制系统</td><td>反过程</td><td>正过程</td></tr></tbody></table><p>判定PID控制器应该采用正作用还是反作用的方法：</p><p>（1）先判定被控对象是正过程还是反过程</p><p>根据控制量与被控量直接的物理因果关系来判断，当控制量增大，被控量也增大时，为正过程；当控制量增大，被控量减小时，为反过程。火电中常见的正过程有：汽机阀门控制（汽机阀门开度增大，蒸汽流量增大）；反过程有：减温水控制（喷水减温阀门开度增大，蒸汽温度减小）。</p><p>（2）根据被控对象选择正反作用</p><p>如果被控对象是反过程则控制器应选择正作用，如果是正过程则选择反作用。</p><h3 id="关于pid的调试技巧">关于PID的调试技巧</h3><blockquote><p>PID的整定方法有很多，这里只是整理一下自己的调试思路。</p></blockquote><p>（1）研究被控对象，确定其是正过程还是反过程，然后确定PID控制器应该采用反作用（正过程）还是正作用（反过程）</p><p>这里以一级过热蒸汽喷水减温控制系统为例：（实际上它的控制系统是一个串级PID，这里为了方便叙述我们简化了，调试的方法的都是类似，只不过串级PID需要先将内环PID先整定好，使得它内环的PV值可以很快的去跟随SP值（外环的输出OP）。）</p><p><img src="一级过热蒸汽喷水减温控制系统.png" alt="图11 一级过热蒸汽喷水减温控制系统" width="60%"></p><p>首先确定我们的目的是通过控制减温水阀门的开度来控制喷水减温的流量，最终将屏式过热器后的蒸汽温度控制在设定值的附近。阀门开度（控制量）增加，蒸汽温度（被控量）减小，所以该被控对象为反过程，PID控制器应该选择正作用。PID控制器的SP为屏式过热器后汽温设定值，PV为屏式过热器后汽温测量值，OP为减温水阀门开度。</p><p>（2）确定纯比例调节的<span class="math inline">\(K_P\)</span>数值</p><blockquote><p>这里提到的 <span class="math inline">\(OP\)</span> 和 <spanclass="math inline">\(u(t)\)</span> 、<spanclass="math inline">\(PV\)</span> 和 <spanclass="math inline">\(y(t)\)</span> 是等价的。</p></blockquote><p>纯比例控制： <span class="math display">\[u(t) = K_P \cdot e(t)\tag{13}\]</span>这里首先需要确定单位OP动作可以影响多少PV，假设PV和OP是存在线性关系的，即</p><p><span class="math display">\[y(t) = K \cdot u(t) + b\tag{14}\]</span></p><p>可以采集历史数据后，进行线性回归获得这个 <spanclass="math inline">\(K\)</span>值，它也被叫做过程模型的增益，或者表示为</p><p><span class="math display">\[K = \frac{\Delta PV}{\Delta OP}\tag{15}\]</span></p><p>此时便确定了单位OP动作可以影响多少PV，即OP每变化单位1，PV会改变单位<spanclass="math inline">\(K\)</span>。所以当PV与SP的偏差为单位1的时候，OP就需要动作<span class="math inline">\(\frac{1}{K}\)</span>，所以这个 <spanclass="math inline">\(\frac{1}{K}\)</span>的绝对值就是纯比例调节应该设置的 <spanclass="math inline">\(K_P\)</span> 值，即： <spanclass="math display">\[K_P = \vert \frac{1}{K} \vert\tag{16}\]</span></p><blockquote><p><strong>解释一下为什么 “<spanclass="math inline">\(\frac{1}{K}\)</span>的绝对值就是纯比例调节应该设置的 <spanclass="math inline">\(K_P\)</span> 值”？</strong></p><p>刚才已经确定了OP每变化单位1，PV会改变单位 <spanclass="math inline">\(K\)</span>，即 <span class="math display">\[\Delta y(t) = K \cdot \Delta u(t)\tag{17}\]</span> 假设 <span class="math inline">\(t\)</span>时刻因阶跃扰动产生了一个控制误差 <span class="math inline">\(e(t) =e_0\)</span>，对于纯比例控制，如果想消除这个偏差 <spanclass="math inline">\(e_0\)</span>，需要让 <spanclass="math inline">\(y(t)\)</span> 改变 <spanclass="math inline">\(e_0\)</span>，那么 <spanclass="math inline">\(\Delta u(t)\)</span> 应该满足 <spanclass="math inline">\(\Delta u(t) = \frac{1}{K} e_0\)</span>，怎么让<span class="math inline">\(\Delta u(t) = \frac{1}{K} e_0\)</span>呢？根据纯比例控制的PID公式可知： <span class="math display">\[\begin{align}&amp; u(t) = K_P \cdot e(t) \\&amp; \implies u(t) - u(t-1) = K_P \cdot \left[ e(t) - e(t-1) \right] \\&amp; \implies \Delta u(t) = K_P \cdot \left[ e_0 - 0 \right] \\&amp; \implies \Delta u(t) = K_P e_0 \\\end{align}\tag{18}\]</span></p><p>当 <span class="math inline">\(K_P = \frac{1}{K}\)</span> 时，<spanclass="math inline">\(\Delta u(t) = \frac{1}{K}e_0\)</span>，但如果系统时反过程，那么 <span class="math inline">\(K&lt; 0\)</span>， 所以 <span class="math inline">\(K_P\)</span> 设为<span class="math inline">\(\frac{1}{K}\)</span> 的绝对值，即<spanclass="math inline">\(K_P = \vert \frac{1}{K} \vert\)</span>。</p></blockquote><p><strong>注意在拟合模型增益 <span class="math inline">\(K\)</span>的时候，要消除系统滞后带来的影响，即拟合：</strong> <spanclass="math display">\[y(t+\tau) = K \cdot u(t) + b\tag{19}\]</span><img src="拟合过程模型的增益.png" alt="图12 拟合过程模型的增益" width="90%"></p><p>如图 12 所示，可以找到一些关联数据段<span class="math inline">\(( \u(t), \ y(t+\tau) \ )\)</span>，拟合出不同时间段（不同工况下）的模型增益<span class="math inline">\(K\)</span>，然后可以利用核密度估计等方法找到它们的中心点作为模型增益 <spanclass="math inline">\(K\)</span> ，进而计算出纯比例控制下的 <spanclass="math inline">\(K_P\)</span> 值。</p><p>（3）将计算得的纯比例调节下的 <spanclass="math inline">\(K_P\)</span> 值和一个较大的<spanclass="math inline">\(T_I\)</span>值（比如 <spanclass="math inline">\(T_I = 1000s\)</span>）设入PID控制器，然后逐渐减小<span class="math inline">\(K_P\)</span>（减小比例作用） 和 <spanclass="math inline">\(T_I\)</span> （增加积分作用）。</p><h2 id="参考">参考</h2><p>[1] 冯少辉. PID 参数整定与复杂控制[M]. 北京: 化学工业出版社,2023(11).</p><h2 id="附件">附件</h2><p>【代码】</p><ol type="1"><li><p><ahref="https://github.com/HuShanzhi/pid_controller_demo/blob/main/pid_simulator_dash.py">基于dash的PID控制仿真器</a></p></li><li><p><ahref="https://github.com/HuShanzhi/pid_controller_demo/blob/main/pid_anlysis.ipynb">PID控制器不同参数的阶跃响应分析</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>控制</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟模型控制</title>
    <link href="/2023/05/07/%E8%99%9A%E6%8B%9F%E6%A8%A1%E5%9E%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/05/07/%E8%99%9A%E6%8B%9F%E6%A8%A1%E5%9E%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是vmc">什么是VMC</h2><p>VMC是一种直觉控制方式，其核心思想是利用假想的虚拟构件(如弹簧、阻尼器、轴承等等)连接机器人内部作用点，或者连接作用点与外部环境，产生相应的虚拟力来“驱使”机器人实现期望的运动。这些虚拟力通过Jacobian矩阵计算得到期望的关节力矩，作为关节控制的输入，驱动机器人运动以产生和虚拟构件一样的作用效果。<strong>VMC的应用关键在于两点：一是在每个需要控制的自由度上构造恰当的虚拟构件以产生合适的虚拟力；二是在不同的相位状态利用相应的Jacobian 矩阵计算期望的关节力矩。</strong></p><h3 id="雅可比矩阵">雅可比矩阵</h3><p>虚拟力不是实际存在的作用力或力矩，机器人的运动最终是通过关节力矩实现的。为了将工作空间(TaskSpace)的力或力矩映射成关节空间(JointSpace)的关节力矩，需要先求得这两个空间的位置映射关系，即正运动学模型：<span class="math display">\[\pmb{x} = f(\pmb{q}) \tag{1}\]</span> 其中，<span class="math inline">\(\pmb{x} = [x_1\ x_2 \ ...x_m]^T\)</span> 为机体坐标系相对于地面坐标系的<spanclass="math inline">\(m\)</span>个自由度对应的位姿向量，<spanclass="math inline">\(\pmb{q} = [q_1 \ q_2 \ ... q_n]^T\)</span> 为<spanclass="math inline">\(n\)</span>个关节变量的位置向量。对式 （1），分别求<span class="math inline">\(\pmb{x}\)</span> 对 <spanclass="math inline">\(\pmb{q}\)</span> 的偏导数得： <spanclass="math display">\[\begin{cases}\delta x_1 = \frac{\partial f1}{\partial q_1} \delta q1 + \ ... +\frac{\partial f1}{\partial q_n} \delta qn \\\vdots \\\delta x_m = \frac{\partial fm}{\partial q_1} \delta q1 + \ ... +\frac{\partial fm}{\partial q_n} \delta qn\\\end{cases}\tag{2}\]</span> 即 <span class="math display">\[\delta \pmb{x} =  \begin{bmatrix}\frac{\partial f1}{\partial q_1}&amp;...&amp;\frac{\partial f1}{\partialq_n} \\\vdots&amp;\ddots&amp;\vdots\\\frac{\partial fm}{\partial q_1}&amp;...&amp;\frac{\partial fm}{\partialq_n} \\\end{bmatrix}\delta \pmb{q}\tag{3}\]</span> 可简写为 <span class="math display">\[\delta \pmb{x}_{(m,1)} = \pmb{J}_{(m,n)} \cdot \delta \pmb{q}_{(n,1)}\tag{4}\]</span> <span class="math inline">\(\pmb{J}_{(m,n)}\)</span>即为雅可比矩阵，它可以将关节速度 <spanclass="math inline">\(\dot{q}\)</span> 映射成机体位姿速度 <spanclass="math inline">\(\dot{x}\)</span>。</p><h3 id="外部作用力和关节力矩的关系">外部作用力和关节力矩的关系</h3><blockquote><p>虚功原理：</p></blockquote><p>根据虚功原理，可得： <span class="math display">\[\pmb{\tau}^T \delta \pmb{q} + (-\pmb{F})^T\delta \pmb{x} = 0\tag{5}\]</span></p><p>其中，<span class="math inline">\(\pmb{\tau} = [\tau_1\ \tau_2 \ ...\tau_n]^T\)</span> 为关节力矩列向量，<spanclass="math inline">\(\pmb{F}=[F_1 \ F_2 \ ... F_m]^T\)</span>为外部作用力。根据式（4）、（5）可得外部作用力和关节力矩之间的关系为：</p><p><span class="math display">\[\pmb{\tau} = \pmb{J}^T \pmb{F}\tag{6}\]</span></p><p>其中，<span class="math inline">\(\pmb{J}\)</span> 为雅可比矩阵。</p><h2 id="示例">示例</h2><h3 id="三自由度机械手臂腿利用-vmc-进行追点">三自由度机械手臂（腿）利用VMC 进行追点</h3><h4 id="机器人环境">机器人环境</h4><p>采用<code>nyu_finger</code>机器人，该机器人来自于项目<ahref="https://github.com/open-dynamic-robot-initiative/nyu_finger">ODRI/ nyu_finger</a>。可以将<code>nyu_finger</code>简化为为一个三自由度机械臂模型，如下所示：</p><figure><img src="三自由度机械臂简化模型.png"alt="图1 三自由度机械臂简化模型" /><figcaption aria-hidden="true">图1 三自由度机械臂简化模型</figcaption></figure><h4 id="正运动学">正运动学</h4><p>首先要求解三自由度机械手臂的正运动学公式，方法如下：</p><ul><li>采用 MDH 法（又称克雷格法）建立坐标系（【注】原论文采用的是 DH法），如下所示：</li></ul><figure><img src="MDH法建立坐标系.png" alt="图2 MDH法建立坐标系" /><figcaption aria-hidden="true">图2 MDH法建立坐标系</figcaption></figure><ul><li><p>建立机器人的连杆参数表；</p><table><thead><tr class="header"><th><span class="math inline">\(i\)</span></th><th><span class="math inline">\(\alpha_{i-1}\)</span></th><th><span class="math inline">\(a_{i-1}\)</span></th><th><span class="math inline">\(d_i\)</span></th><th><span class="math inline">\(\theta_{i}\)</span></th></tr></thead><tbody><tr class="odd"><td>1</td><td>0</td><td>0</td><td>0</td><td><span class="math inline">\(\theta_1\)</span></td></tr><tr class="even"><td>2</td><td><span class="math inline">\(-\pi/2\)</span></td><td>0</td><td><span class="math inline">\(D_2\)</span></td><td><span class="math inline">\(\theta_2\)</span></td></tr><tr class="odd"><td>3</td><td>0</td><td><span class="math inline">\(L_2\)</span></td><td><span class="math inline">\(D_3\)</span></td><td><span class="math inline">\(\theta_3\)</span></td></tr><tr class="even"><td>4</td><td>0</td><td><span class="math inline">\(L_3\)</span></td><td>0</td><td>0</td></tr></tbody></table></li><li><p>求末坐标系和初坐标系之间得变换矩阵 <spanclass="math inline">\(^0_4T\)</span></p><blockquote><p>两个相邻坐标系之间的变换矩阵通式为： <span class="math display">\[^{i-1}_iT =\begin{bmatrix}cos\theta_i&amp;-sin\theta_i&amp;0&amp;a_{i-1}\\cos\alpha_{i-1} sin\theta_i&amp;cos\alpha_{i-1}cos\theta_i&amp;-sin\alpha_{i-1} &amp;-d_isin\alpha_{i-1} \\sin\alpha_{i-1} sin\theta_i&amp;sin\alpha_{i-1}cos\theta_i&amp;cos\alpha_{i-1} &amp;d_icos\alpha_{i-1} \\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\\tag{7}\]</span></p></blockquote><p>首先，根据式（7），求出所有的两个相邻坐标系之间的变换矩阵为： <spanclass="math display">\[^0_1T =\begin{bmatrix}cos\theta_1&amp;-sin\theta_1&amp;0&amp;0\\sin\theta_1&amp;cos\theta_1&amp;0 &amp;0 \\0 &amp;0 &amp;1 &amp;0 \\0 &amp;0 &amp;0 &amp;1\\\end{bmatrix} \\\tag{8}\]</span></p><p><span class="math display">\[^1_2T =\begin{bmatrix}cos\theta_2&amp;-sin\theta_2&amp;0&amp;0\\0 &amp;0 &amp;1 &amp;D_2\\-sin\theta_2 &amp;-cos\theta_2 &amp;0 &amp;0 \\0 &amp;0 &amp;0 &amp;1\\\end{bmatrix} \\  \tag{9}\]</span></p><p><span class="math display">\[^2_3T =\begin{bmatrix}cos\theta_3&amp;-sin\theta_3&amp;0&amp;L_2\\sin\theta_3&amp;cos\theta_3&amp;0 &amp;0 \\0 &amp;0 &amp;1 &amp;D_3 \\0 &amp;0 &amp;0 &amp;1\\\end{bmatrix} \\\tag{10}\]</span></p><p><span class="math display">\[^3_4T =\begin{bmatrix}1 &amp;0 &amp;0 &amp;L_3\\0 &amp;1 &amp;0 &amp;0 \\0 &amp;0 &amp;1 &amp;0 \\0 &amp;0 &amp;0 &amp;1\\\end{bmatrix} \\\tag{11}\]</span></p><p>然后，将上述变换矩阵累乘得： <span class="math display">\[^0_4T = ^0_1T ^1_2T^2_3T^3_4T \\=\begin{bmatrix}c_1c_{23} &amp;-c_1s_{23} &amp;-s_1&amp;c_1(L_2c_2+L_3c_{23})-s_1(D_2+D_3)\\s_1c_{23} &amp;-s_1s_{23} &amp;c_1&amp;s_1(L_2c_2+L_3c_{23})+c_1(D_2+D_3) \\-s_{23} &amp;-c_{23} &amp;0 &amp;-L_2s_2-L_3s_{23} \\0 &amp;0 &amp;0 &amp;1\\\end{bmatrix} \\\tag{12}\]</span></p><blockquote><p>【注】<span class="math inline">\(c_1\)</span> 为 <spanclass="math inline">\(cos\theta_1\)</span>的简写，<spanclass="math inline">\(c_{23}\)</span> 为 <spanclass="math inline">\(cos(\theta_2+\theta_3)\)</span>的简写，其余类似。</p></blockquote></li><li><p>求末端点在0号坐标系中的表示</p><p>根据式（12），在0号坐标系表示末端点（4号坐标系的原点）为 <spanclass="math display">\[^0P_{origin_4} =\begin{bmatrix}c_1(L_2c_2+L_3c_{23})-s_1(D_2+D_3)\\s_1(L_2c_2+L_3c_{23})+c_1(D_2+D_3) \\-L_2s_2-L_3s_{23} \\\end{bmatrix} \\\tag{13}\]</span></p><p>式（13）即为式（1）描述的正运动学模型 <spanclass="math inline">\(\pmb{x} = f(\pmb{q}) \tag{1}\)</span>，其中，<spanclass="math inline">\(\pmb{x} =\ ^0P_{origin_4}=  [^0x_{origin_4}\^0y_{origin_4}\ ^0z_{origin_4}]^T\)</span>，<spanclass="math inline">\(\pmb{q} = [\theta_1 \ \theta_2 \\theta_3]^T\)</span> 。</p></li></ul><p><em>当然，上述矩阵的求解没有人会希望通过手算来解决，可以利用matlab写一个简单脚本进行计算：</em></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 用于生成变换矩阵.</span><br><span class="hljs-comment">% @filename: generate_T.m</span><br><span class="hljs-comment">% @functionname: generate_T</span><br><span class="hljs-comment">% @args: </span><br><span class="hljs-comment">%   alpha, a, d, theta.</span><br><span class="hljs-comment">% @return:</span><br><span class="hljs-comment">%   T.</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">T</span> = <span class="hljs-title">generate_T</span><span class="hljs-params">(alpha, a, d, theta)</span></span><br><span class="hljs-comment">% 这里的T矩阵是式（7）的矩阵</span><br>T = [<span class="hljs-built_in">cos</span>(theta) -<span class="hljs-built_in">sin</span>(theta) <span class="hljs-number">0</span> a;<br>     <span class="hljs-built_in">cos</span>(alpha)*<span class="hljs-built_in">sin</span>(theta) <span class="hljs-built_in">cos</span>(alpha)*<span class="hljs-built_in">cos</span>(theta) -<span class="hljs-built_in">sin</span>(alpha) -d*<span class="hljs-built_in">sin</span>(alpha);<br>     <span class="hljs-built_in">sin</span>(alpha)*<span class="hljs-built_in">sin</span>(theta) <span class="hljs-built_in">sin</span>(alpha)*<span class="hljs-built_in">cos</span>(theta) <span class="hljs-built_in">cos</span>(alpha) d*<span class="hljs-built_in">cos</span>(alpha);<br>     <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>];<br><br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 1. 计算末坐标系相对于初坐标系的变换矩阵</span><br><span class="hljs-comment">% 2. 在初坐标系中描述末坐标系的原点</span><br><span class="hljs-comment">% @filename: mian.m</span><br><br>clc,clear,close all;<br>syms th1 th2 th3;<br>syms l1 l2 l3;<br>syms d1 d2 d3;<br>syms PI;<br><br>T01 = generate_T(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, th1);<br>T12 = generate_T(-PI/<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, d2, th2);<br>T23 = generate_T(<span class="hljs-number">0</span>, l2, d3, th3);<br>T34 = generate_T(<span class="hljs-number">0</span>, l3, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>P = T01*T12*T23*T34;<br>P = subs(P,PI,<span class="hljs-built_in">pi</span>); <span class="hljs-comment">% For solving the problem: cos(pi/2) != 0.</span><br>P_simplify = simplify(P)<br><br>pos = P_simplify(<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><br><span class="hljs-comment">% jacobian(pos, [th1, th2, th3])</span><br><br></code></pre></td></tr></table></figure><h4 id="求雅可比矩阵">求雅可比矩阵</h4><p>根据式（2）对式（13）求偏导得： <span class="math display">\[\delta \pmb{x} =  \begin{bmatrix}-s_1(L_2c_2+L_3c_{23})-c_1(D_2+D_3) &amp;-c_1(L_2s_2+L_3s_{23})&amp;-L_3c_1s_{23}\\c_1(L_2c_2+L_3c_{23})-s_1(D_2+D_3) &amp;-s_1(L_2s_2+L_3s_{23})&amp;-L_3s_1s_{23}\\0 &amp;-L_2c_2-L_3c_{23} &amp;-L_3c_{23}\\\end{bmatrix}\delta \pmb{q}\tag{14}\]</span></p><p>由式（14）得雅可比矩阵为 <span class="math display">\[\pmb{J} =\begin{bmatrix}-s_1(L_2c_2+L_3c_{23})-c_1(D_2+D_3) &amp;-c_1(L_2s_2+L_3s_{23})&amp;-L_3c_1s_{23}\\c_1(L_2c_2+L_3c_{23})-s_1(D_2+D_3) &amp;-s_1(L_2s_2+L_3s_{23})&amp;-L_3s_1s_{23}\\0 &amp;-L_2c_2-L_3c_{23} &amp;-L_3c_{23}\\\end{bmatrix}\tag{15}\]</span></p><p><em>当然，雅可比的计算也可用代码完成，如下所示：</em></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 1. 计算末坐标系相对于初坐标系的变换矩阵</span><br><span class="hljs-comment">% 2. 在初坐标系中描述末坐标系的原点</span><br><span class="hljs-comment">% 3. 计算雅可比矩阵</span><br><span class="hljs-comment">% @filename: mian.m</span><br><br>clc,clear,close all;<br>syms th1 th2 th3;<br>syms l1 l2 l3;<br>syms d1 d2 d3;<br>syms PI;<br><br>T01 = generate_T(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, th1);<br>T12 = generate_T(-PI/<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, d2, th2);<br>T23 = generate_T(<span class="hljs-number">0</span>, l2, d3, th3);<br>T34 = generate_T(<span class="hljs-number">0</span>, l3, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>P = T01*T12*T23*T34;<br>P = subs(P,PI,<span class="hljs-built_in">pi</span>);<br>P_simplify = simplify(P)<br><br>pos = P_simplify(<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><br>jacobian(pos, [th1, th2, th3])<br><br></code></pre></td></tr></table></figure><h4 id="假设虚拟力">假设虚拟力</h4><p>假设用一个虚拟构件（弹簧阻尼器）连接机械臂末端和外界，将该虚拟构件产生的作用在机械臂末端点的虚拟力记为<spanclass="math inline">\(F\)</span>，可将虚拟力<spanclass="math inline">\(F\)</span>分解到三个方向，即 <spanclass="math display">\[\pmb{F} =\begin{bmatrix}F_x\\F_y\\F_z\\\end{bmatrix}=\begin{bmatrix}k_x &amp;0 &amp;0\\0 &amp;k_y &amp;0\\0 &amp;0 &amp;k_z\\\end{bmatrix}\begin{bmatrix}x_d - x\\y_d - y\\z_d - z\\\end{bmatrix}+\begin{bmatrix}b_x &amp;0 &amp;0\\0 &amp;b_y &amp;0\\0 &amp;0 &amp;b_z\\\end{bmatrix}\begin{bmatrix}\dot{x_d} - \dot{x}\\\dot{y_d} - \dot{y}\\\dot{z_d} - \dot{z}\\\end{bmatrix}\tag{16}\]</span></p><h4 id="求解扭矩">求解扭矩</h4><p>将式（15）、（16）代入式（6）可得关节力矩。</p><h4 id="代码">代码</h4><p><ahref="https://github.com/HuShanzhi/demo_quadruped_VMC">demo_quadruped_VMC</a></p><h2 id="参考">参考</h2><p>[1] 谢惠祥. 四足机器人对角小跑步态虚拟模型直觉控制方法研究[D].国防科学技术大学[2025]</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">@phdthesis&#123;谢惠祥0四足机器人对角小跑步态虚拟模型直觉控制方法研究,<br>  title=&#123;四足机器人对角小跑步态虚拟模型直觉控制方法研究&#125;,<br>  author=&#123;谢惠祥&#125;,<br>  school=&#123;国防科学技术大学&#125;,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器人</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正逆运动学笔记</title>
    <link href="/2023/05/07/%E6%AD%A3%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/05/07/%E6%AD%A3%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="rotation-matrix">Rotation Matrix</h2><p>旋转矩阵的作用：</p><ol type="1"><li>描述物体的姿态；</li><li>将point由某一个frame的表述换到另一个和此frame有相对转动的frame上来表述；</li><li>...</li></ol><h2 id="homogeneous-transformation-matrix">Homogeneous TransformationMatrix</h2><p>齐次变换矩阵...</p><h2 id="forward-kinematics">Forward Kinematics</h2><h3 id="什么是正运动学">什么是正运动学</h3><p>正运动学就是通过关节的驱动来推出机器末端的位姿。</p><h3 id="建立关节坐标系">建立关节坐标系</h3><p>建立坐标系的方法有两种：一种是<strong>克雷格（CraigVersion）</strong>；<del>另一种是<strong>Standard</strong></del>。</p><figure><img src="机械手臂几何描述方式示意图.png"alt="图1 机械手臂几何描述方式示意图" /><figcaption aria-hidden="true">图1机械手臂几何描述方式示意图</figcaption></figure><p>如图1所示，对于一个关节（无论是转动关节还是移动关节），总能找到一个关节轴，记为Axis。当然对于转动关节，Axis就是转轴；对于移动关节，Axis就是移动轴。两个相邻的Axis之间有两种情况：一种是异面直线，一种是共面且平行直线。所以，两个相邻的Axis之间一定存在一条直线。</p><p>如图1所示，对于一个由Joint和Link复合的一个机械结构，一般通过4个参数进行描述<spanclass="math inline">\(\alpha、a、d、\theta\)</span>。其中，<spanclass="math inline">\(\alpha\)</span>表示两个Joint转轴之间的角度，<spanclass="math inline">\(a\)</span>表示两个转轴之间的距离，<spanclass="math inline">\(d\)</span>表示两个Link之间的偏移值，<spanclass="math inline">\(\theta\)</span>表示Joint的转动角度。（<spanclass="math inline">\(\alpha_i, a_i, d_i,\theta_i\)</span>）可以用来表示第i个Joint的信息。对于转动关节来说，它的<spanclass="math inline">\(\theta\)</span>是可变参数；对于移动关节来说，它的<spanclass="math inline">\(d\)</span>是可变参数。</p><p>如图2所示，需要给每个Joint建立坐标系（<spanclass="math inline">\(\widehat{X}_i, \widehat{Y}_i,\widehat{Z}_i\)</span>），其中，<spanclass="math inline">\(\widehat{Z}_i\)</span>沿转轴Axis（转动或移动）的方向。<spanclass="math inline">\(\widehat{X}_i\)</span>有两种情况：一是当<spanclass="math inline">\(a_i \neq 0\)</span>时，它沿着<spanclass="math inline">\(a_i\)</span>的方向；二是当<spanclass="math inline">\(a_i = 0\)</span>时，它与<spanclass="math inline">\(\widehat{Z}_i和\)</span><spanclass="math inline">\(\widehat{Z}_{i+1}\)</span>两者垂直（i.e. 它为<spanclass="math inline">\(\widehat{Z}_i和\)</span><spanclass="math inline">\(\widehat{Z}_{i+1}\)</span>的叉积的单位向量）。<spanclass="math inline">\(\widehat{Y}_i\)</span>与<spanclass="math inline">\(\widehat{X}_i和\)</span><spanclass="math inline">\(\widehat{Z}_{i}\)</span>两者垂直，且遵循右手定则，即<spanclass="math inline">\(\widehat{Y}_i = \widehat{Z}_{i} \times\widehat{X}_{i}\)</span>。<strong>注意Z和X的顺序。</strong></p><figure><img src="建立关节坐标系.png" alt="图2 建立关节坐标系" /><figcaption aria-hidden="true">图2 建立关节坐标系</figcaption></figure><p>上述为普遍地建立坐标系的方法。此外，还有两种特殊情况：一是对于地杆Link0，为了简化计算，<strong>一般都将Link 1的坐标系作为Link0的坐标系。</strong>如果Joint 1是转动关节，则把<spanclass="math inline">\(\theta_1 = 0\)</span>时的Link 1的坐标系作为Link0的坐标系；如果Joint 1是移动关节，则把<span class="math inline">\(d_1  =0\)</span>时的Link 1的坐标系作为Link 0的坐标系。二是对于最后一个Linkn，Joint n无法确定一个<spanclass="math inline">\(a_n\)</span>，进而无法确定<spanclass="math inline">\(\widehat{X}_n\)</span>。一般的解决办法是让<spanclass="math inline">\(\theta_n=0\)</span>时的<spanclass="math inline">\(\widehat{X}_n\)</span>的方向与<spanclass="math inline">\(\widehat{X}_{n-1}\)</span>保持相同（<del>【注】：我感觉是从末端向Axisn做垂线，然后用垂线来确定<spanclass="math inline">\(\widehat{X}_n\)</span></del>）。</p><figure><img src="Link0建立坐标系.png" alt="图3 Link 0建立坐标系" /><figcaption aria-hidden="true">图3 Link 0建立坐标系</figcaption></figure><figure><img src="Linkn建立坐标系.png" alt="图4 Link n建立坐标系" /><figcaption aria-hidden="true">图4 Link n建立坐标系</figcaption></figure><h3 id="杆件之间的变换矩阵">杆件之间的变换矩阵</h3><p><span class="math display">\[^{i-1}P = ^{i-1}_iT^iP \tag{1}\]</span></p><p><img src="两个杆件坐标系转化过程示意图.png"alt="图5 两个杆件坐标系转化过程示意图" /> <span class="math display">\[^{i-1}P = ^{i-1}_RT ^R_QT ^Q_PT ^P_iT ^iP \tag{2}\]</span></p><p><span class="math display">\[\begin{align}^{i-1}_iT &amp;= ^{i-1}_RT ^R_QT ^Q_PT ^P_iT \\&amp;= T_{\widehat{X}_{i-1}}(\alpha_{i-1})T_{\widehat{X}_{R}}(a_{i-1})  T_{\widehat{Z}_{Q}}(\theta_{i})T_{\widehat{Z}_{P}}(d_{i}) \\&amp;=\begin{bmatrix}cos\theta_i&amp;-sin\theta_i&amp;0&amp;a_{i-1}\\cos\alpha_{i-1} sin\theta_i&amp;cos\alpha_{i-1}cos\theta_i&amp;sin\alpha_{i-1} &amp;d_isin\alpha_{i-1} \\-sin\alpha_{i-1} sin\theta_i&amp;-sin\alpha_{i-1}cos\theta_i&amp;cos\alpha_{i-1} &amp;d_icos\alpha_{i-1} \\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\\end{align}\tag{3}\]</span></p><p><del><code>【注】式（3）的结果和林沛群教授课件上的不同，个人感觉是他出错了。</code></del></p><p><code>【注】式（3）有误，应为式（3b）。林是对的。</code> <spanclass="math display">\[\begin{align}^{i-1}_iT &amp;= ^{i-1}_RT ^R_QT ^Q_PT ^P_iT \\&amp;= T_{\widehat{X}_{i-1}}(\alpha_{i-1})T_{\widehat{X}_{R}}(a_{i-1})  T_{\widehat{Z}_{Q}}(\theta_{i})T_{\widehat{Z}_{P}}(d_{i}) \\&amp;=\begin{bmatrix}cos\theta_i&amp;-sin\theta_i&amp;0&amp;a_{i-1}\\cos\alpha_{i-1} sin\theta_i&amp;cos\alpha_{i-1}cos\theta_i&amp;-sin\alpha_{i-1} &amp;-d_isin\alpha_{i-1} \\sin\alpha_{i-1} sin\theta_i&amp;sin\alpha_{i-1}cos\theta_i&amp;cos\alpha_{i-1} &amp;d_icos\alpha_{i-1} \\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\\end{align}\tag{3b}\]</span></p><p><span class="math display">\[\begin{align}T_{\widehat{X}_{i-1}}(\alpha_{i-1}) &amp;=\begin{bmatrix}&amp;&amp;&amp;0\\&amp;R_{\widehat{X}_{i-1}}(\alpha_{i-1})&amp;&amp;0\\&amp;&amp;&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\&amp;=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;cos\alpha_{i-1}&amp;sin\alpha_{i-1}&amp;0\\0&amp;-sin\alpha_{i-1}&amp;cos\alpha_{i-1}&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\\end{align}\tag{4}\]</span></p><p><code>【注】式（3）的错误是由式（4）的错误引起的，式（4）应为式（4b）。但是，目前还不知道为什么是式（4b）。</code></p><blockquote><p>现在解释一下为什么是 4b 而不是 4：（<strong>这是因为 Rotation Matrix部分没学好。</strong>）</p><p>我们从 <span class="math inline">\(\widehat{X}_{i-1}\)</span>的方向向 <span class="math inline">\(\widehat{X}_{i-1}\)</span>的负方向看去，坐标系 <span class="math inline">\(\{i-1\}\)</span> 绕<span class="math inline">\(\widehat{X}\)</span>轴<strong>顺时针</strong>旋转 <spanclass="math inline">\(\alpha\)</span> 度获得坐标系 <spanclass="math inline">\(\{R\}\)</span> 。然后，将坐标系 <spanclass="math inline">\(\{R\}\)</span> 的 <spanclass="math inline">\(\widehat{Z}_R\)</span> 和 <spanclass="math inline">\(\widehat{Y}_R\)</span> 轴依次向坐标系 <spanclass="math inline">\(\{i-1\}\)</span>做投影，应该是获得式（4）而不是式（4b），<strong>但是</strong>，<spanclass="math inline">\(\alpha\)</span>角是有方向的，顺时针旋转为负。因此，式（4）应该改为： <spanclass="math display">\[\begin{align}T_{\widehat{X}_{i-1}}(-\alpha_{i-1}) &amp;=\begin{bmatrix}&amp;&amp;&amp;0\\&amp;R_{\widehat{X}_{i-1}}(-\alpha_{i-1})&amp;&amp;0\\&amp;&amp;&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\&amp;=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;cos(-\alpha_{i-1})&amp;sin(-\alpha_{i-1})&amp;0\\0&amp;-sin(-\alpha_{i-1})&amp;cos(-\alpha_{i-1})&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\\end{align}\]</span></p><p>做三角变换可得到式 （4b）。</p></blockquote><p><span class="math display">\[\begin{align}T_{\widehat{X}_{i-1}}(\alpha_{i-1}) &amp;=\begin{bmatrix}&amp;&amp;&amp;0\\&amp;R_{\widehat{X}_{i-1}}(\alpha_{i-1})&amp;&amp;0\\&amp;&amp;&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\&amp;=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;cos\alpha_{i-1}&amp;-sin\alpha_{i-1}&amp;0\\0&amp;sin\alpha_{i-1}&amp;cos\alpha_{i-1}&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\\end{align}\tag{4b}\]</span></p><p><span class="math display">\[\begin{align}T_{\widehat{X}_{R}}(a_{i-1}) &amp;=\begin{bmatrix}1&amp;0&amp;0&amp;\\0&amp;1&amp;0&amp;P_{\widehat{X}_{R}}(a_{i-1})\\0&amp;0&amp;1&amp;\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\&amp;=\begin{bmatrix}1&amp;0&amp;0&amp;a_{i-1}\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\\end{align}\tag{5}\]</span></p><p><span class="math display">\[\begin{align}T_{\widehat{Z}_{Q}}(\theta_{i}) &amp;=\begin{bmatrix}&amp;&amp;&amp;0\\&amp;R_{\widehat{Z}_{Q}}(\theta_{i})&amp;&amp;0\\&amp;&amp;&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\&amp;=\begin{bmatrix}cos\theta_{i}&amp;-sin\theta_{i}&amp;0&amp;0\\sin\theta_{i}&amp;cos\theta_{i}&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\\end{align}\tag{6}\]</span></p><p><span class="math display">\[\begin{align}T_{\widehat{Z}_{P}}(d_{i}) &amp;=\begin{bmatrix}1&amp;0&amp;0&amp;\\0&amp;1&amp;0&amp;P_{\widehat{Z}_{P}}(d_{i})\\0&amp;0&amp;1&amp;\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\&amp;=\begin{bmatrix}1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;d_{i}\\0&amp;0&amp;0&amp;1\\\end{bmatrix} \\\end{align}\tag{7}\]</span></p><p>进一步，第一个杆件和最后一个杆件之间的变换矩阵为式（8）。</p><p><span class="math display">\[^{0}_nT = ^{0}_1T^{1}_2T^{2}_3T ... ^{n-2}_{n-1}T^{n-1}_{n}T    \tag{8}\]</span></p><h3 id="instance">Instance</h3><p>我们通过一个简单的二连杆进行一次正运动学推导。</p><figure><img src="二连杆示意图.png" alt="图6 二连杆示意图" /><figcaption aria-hidden="true">图6 二连杆示意图</figcaption></figure><p>给图中二连杆的各个关节建立坐标系。</p><blockquote><p>【分析】：</p><ul><li>给Joint 1建立坐标系（即第1个坐标系）：</li></ul><ol type="1"><li><p>Joint 1 和 Joint 2 的转轴Axis垂直于平面，且相互平行。因此，<spanclass="math inline">\(\alpha_1=0\)</span>，<spanclass="math inline">\(a_1=\{link1的长度\}\)</span>；</p></li><li><p><span class="math inline">\(\widehat{X_1}\)</span>的方向沿<spanclass="math inline">\(a_1\)</span>，<spanclass="math inline">\(\widehat{Z_1}\)</span>的方向设为沿Joint1的转轴向外，进而，可得<span class="math inline">\(\widehat{Y_1} =\widehat{X_1}  \times \widehat{Z_1}\)</span>。</p></li></ol><ul><li>给基座建立坐标系（即第0个坐标系）：</li></ul><ol type="1"><li>把<spanclass="math inline">\(\theta_1=0\)</span>时的第1个坐标系作为第0个坐标系。</li></ol><ul><li>给Joint 2建立坐标系（即第2个坐标系）：</li></ul><ol type="1"><li>首先最关键的是要确定<spanclass="math inline">\(\widehat{X_2}\)</span>的方向。将<spanclass="math inline">\(\widehat{X_1}\)</span>的方向作为<spanclass="math inline">\(\theta_2=0\)</span>时的<spanclass="math inline">\(\widehat{X_2}\)</span>的方向；</li><li><span class="math inline">\(\widehat{Z_2}\)</span>的方向设为沿Joint2的转轴向外，进而，可得<span class="math inline">\(\widehat{Y_2} =\widehat{X_2}  \times \widehat{Z_2}\)</span>。</li></ol></blockquote><figure><img src="二连杆建立关节坐标系.png" alt="图7 二连杆建立关节坐标系" /><figcaption aria-hidden="true">图7 二连杆建立关节坐标系</figcaption></figure><table><thead><tr class="header"><th><span class="math inline">\(i\)</span></th><th><span class="math inline">\(\alpha_{i-1}\)</span></th><th><span class="math inline">\(a_{i-1}\)</span></th><th><span class="math inline">\(d_i\)</span></th><th><span class="math inline">\(\theta_{i}\)</span></th></tr></thead><tbody><tr class="odd"><td>1</td><td>0</td><td>0</td><td>0</td><td><span class="math inline">\(\theta_1\)</span></td></tr><tr class="even"><td>2</td><td>0</td><td><span class="math inline">\(L_1\)</span></td><td>0</td><td><span class="math inline">\(\theta_2\)</span></td></tr></tbody></table><p>记二连杆的末端点为<span class="math inline">\(P\)</span>，令<spanclass="math inline">\(P\)</span>在 Joint 2 的坐标系下的位置为<spanclass="math inline">\(^2P = (L_2, 0,0)^T\)</span>。假设基坐标系为世界坐标系。 <span class="math display">\[\begin{bmatrix}&amp; \\^0P \\&amp; \\1 \\  \end{bmatrix}  = ^0_1T ^1_2T\begin{bmatrix}&amp; \\^2P \\&amp; \\1 \\  \end{bmatrix}  \tag{9}\]</span></p><p><span class="math display">\[\begin{align}^0P &amp;=\begin{bmatrix}cos\theta_1&amp;-sin\theta_1&amp;0&amp;a_{0}\\cos\alpha_{0} sin\theta_1&amp;cos\alpha_{0}cos\theta_1&amp;sin\alpha_{0} &amp;d_1sin\alpha_{0} \\-sin\alpha_{0} sin\theta_1&amp;-sin\alpha_{0}cos\theta_1&amp;cos\alpha_{0} &amp;d_1cos\alpha_{0} \\0&amp;0&amp;0&amp;1\\\end{bmatrix}  \begin{bmatrix}cos\theta_2&amp;-sin\theta_2&amp;0&amp;a_{1}\\cos\alpha_{1} sin\theta_2&amp;cos\alpha_{1}cos\theta_2&amp;sin\alpha_{1} &amp;d_2sin\alpha_{1} \\-sin\alpha_{1} sin\theta_2&amp;-sin\alpha_{1}cos\theta_2&amp;cos\alpha_{1} &amp;d_2cos\alpha_{1} \\0&amp;0&amp;0&amp;1\\\end{bmatrix}{^2P}\\&amp;=\begin{bmatrix}cos\theta_1&amp;-sin\theta_1&amp;0&amp;0\\sin\theta_1&amp;cos\theta_1&amp;0 &amp;0 \\0&amp;0&amp;1 &amp;0 \\0&amp;0&amp;0&amp;1\\\end{bmatrix}  \begin{bmatrix}cos\theta_2&amp;-sin\theta_2&amp;0&amp;L_{1}\\sin\theta_2&amp;cos\theta_2&amp;0 &amp;0 \\0&amp;0&amp;1 &amp;0 \\0&amp;0&amp;0&amp;1\\\end{bmatrix}  {^2P} \\&amp;=\begin{bmatrix}cos\theta_{1}cos\theta_2-sin\theta_{1}sin\theta_{2}&amp;-cos\theta_{1}sin\theta_2sin\theta_{1}cos\theta_{2}&amp;0&amp;L_{1}cos\theta_{1}\\sin\theta_1cos\theta_{2}+cos\theta_{1}sin\theta_{2}&amp;-sin\theta_{1}sin\theta_{2}+cos\theta_{1}cos\theta_2&amp;0&amp;L_1sin\theta_{1} \\0&amp;0&amp;1 &amp;0 \\0&amp;0&amp;0&amp;1\\\end{bmatrix}  \begin{bmatrix}L_{2}\\0 \\0 \\1\\\end{bmatrix} \\&amp;=\begin{bmatrix}(cos\theta_{1}cos\theta_2-sin\theta_{1}sin\theta_{2})L_2+L_{1}cos\theta_{1}\\(sin\theta_1cos\theta_{2}+cos\theta_{1}sin\theta_{2})L_2+L_1sin\theta_{1}\\0 \\1\\\end{bmatrix}  \\&amp;=\begin{bmatrix}cos(\theta_{1}+\theta_{2})L_2+L_{1}cos\theta_{1}\\sin(\theta_{1}+\theta_{2})L_2+L_1sin\theta_{1} \\0 \\1\\\end{bmatrix}\end{align}\tag{10}\]</span></p><h2 id="inverse-kinematics">Inverse Kinematics</h2><h3 id="什么是逆运动学">什么是逆运动学</h3><p>逆运动学就是通过机器末端的位姿来反推各个关节的驱动。</p><h3 id="求解方法">求解方法</h3><ul><li>解析法<ul><li>代数和几何方法</li></ul></li><li>数值法<ul><li>用计算机试值</li></ul></li><li>目前大多数机械臂设计成具有解析解<ul><li>对于一个六轴机械臂，设计时让它的相邻三轴相交一点，一般这样的手臂就能找到解析解。目前，机械臂多将后三个轴相交一点。</li></ul></li></ul><h3 id="instance-1">Instance</h3><figure><img src="二连杆逆运动学.png" alt="图8 二连杆逆运动学" /><figcaption aria-hidden="true">图8 二连杆逆运动学</figcaption></figure><p>假设基坐标系为世界坐标系。令<spanclass="math inline">\(P\)</span>为目标点，已知<spanclass="math inline">\(P\)</span>点在世界坐标系的坐标为<spanclass="math inline">\((x, y, z)=(x, y, 0)\)</span>，进而可以推出Joint2坐标系原点的坐标为<span class="math inline">\((x-L_2cos\varphi,y-L_2sin\varphi, 0)\)</span>，因此Joint2坐标系相对于世界坐标系的变换矩阵<spanclass="math inline">\(^0_2T\)</span>可以表示为 <spanclass="math display">\[\begin{bmatrix}cos\varphi&amp;-sin\varphi&amp;0&amp;x-L_2cos\varphi\\sin\varphi&amp;cos\varphi&amp;0&amp;y-L_2sin\varphi \\0&amp;0&amp;1&amp;0 \\0&amp;0&amp;0&amp;1\\\end{bmatrix}\tag{11}\]</span> 根据正运动学公式<spanclass="math inline">\(^0_2T\)</span>还可以表示为 <spanclass="math display">\[\begin{bmatrix}cos\theta_{1}cos\theta_2-sin\theta_{1}sin\theta_{2}&amp;-cos\theta_{1}sin\theta_2-sin\theta_{1}cos\theta_{2}&amp;0&amp;L_{1}cos\theta_{1}\\sin\theta_1cos\theta_{2}+cos\theta_{1}sin\theta_{2}&amp;-sin\theta_{1}sin\theta_{2}+cos\theta_{1}cos\theta_2&amp;0&amp;L_1sin\theta_{1} \\0&amp;0&amp;1 &amp;0 \\0&amp;0&amp;0&amp;1\\\end{bmatrix}\tag{12}\]</span> 根据三角公式进一步化简得 <span class="math display">\[\begin{bmatrix}cos(\theta_{1}+\theta_2)&amp;-sin(\theta_1+\theta_{2})&amp;0&amp;L_{1}cos\theta_{1}\\sin(\theta_1+\theta_{2})&amp;cos(\theta_{1}+\theta_{2})&amp;0&amp;L_1sin\theta_{1} \\0&amp;0&amp;1 &amp;0 \\0&amp;0&amp;0&amp;1\\\end{bmatrix}\tag{13}\]</span></p><h4 id="代数法">代数法</h4><p>联立式（11）和（13）得 <span class="math display">\[\begin{cases}cos\varphi= cos(\theta_1+\theta_2)\\sin\varphi= sin(\theta_1+\theta_2)\\x-L_2cos\varphi=L_1cos\theta_1\\y-L_2sin\varphi=L_1sin\theta_1\\\end{cases}\tag{14}\]</span></p><p><span class="math display">\[\begin{cases}x= L_1cos\theta_1 + L_2cos(\theta_1+\theta_2)\\y= L_1sin\theta_1 + L_2sin(\theta_1+\theta_2)\\\end{cases}\tag{15}\]</span></p><p><span class="math display">\[\begin{align}x^2 + y^2 &amp;= L_1^2 + L_2^2 +2L_1L_2[cos\theta_1cos(\theta_1+\theta_2) +sin\theta_1sin(\theta_1+\theta_2)] \\&amp;= L_1^2 + L_2^2 + 2L_1L_2cos\theta_2\end{align}\tag{16}\]</span></p><p><span class="math display">\[\theta_2 = \pm arccos(\frac{x^2+y^2-L_1^2-L_2^2}{2L_1L_2})\]</span></p><p><span class="math display">\[\begin{cases}x= L_1cos\theta_1 + L_2cos(\theta_1+\theta_2) =(L_1+L_2cos\theta_2)cos\theta_1+(-L_2sin\theta_2)sin\theta_1\\y= L_1sin\theta_1 + L_2sin(\theta_1+\theta_2) =(L_1+L_2cos\theta_2)sin\theta_1 + (\, \, \, \,\,  L_2sin\theta_2)cos\theta_1\\\end{cases}\tag{17}\]</span></p><p><span class="math display">\[\begin{cases}x \triangleq k_1cos\theta_1 - k_2sin\theta_1 \\y \triangleq k_1sin\theta_1 + k_2cos\theta_1\\\end{cases}\tag{18}\]</span></p><p><span class="math display">\[r = + \sqrt{k_1^2+k_2^2} \\\gamma=arctan(k_2/k_1)\tag{19}\]</span></p><p><span class="math display">\[k_1 = r cos\gamma \\k_2 = r sin\gamma\tag{20}\]</span></p><p><span class="math display">\[\begin{cases}\frac{x}{r} = cos\gamma cos\theta_1 - sin\gamma sin\theta_1 = cos(\gamma+ \theta_1) \\\frac{y}{r} = cos\gamma sin\theta_1 - sin\gamma cos\theta_1 = sin(\gamma+ \theta_1)\end{cases}\tag{21}\]</span></p><p><span class="math display">\[tan(\gamma + \theta_1) = y/x \\\theta_1 = arctan(y/x) - \gamma =  arctan(y/x) - arctan(k_2/k_1)\tag{22}\]</span></p><h4 id="几何法">几何法</h4><figure><img src="二连杆逆运动学几何求解法.png"alt="图9 二连杆逆运动学几何求解法" /><figcaption aria-hidden="true">图9 二连杆逆运动学几何求解法</figcaption></figure><p>连接<span class="math inline">\(P\)</span>点和基坐标系原点，记为<spanclass="math inline">\(L_0\)</span>，<span class="math inline">\(L_0 =\sqrt{x^2+y^2}\)</span>。对三角形<spanclass="math inline">\(\bigtriangleup_{L_0L_1L_2}\)</span>做一个余弦定理得<span class="math display">\[L_0^2 = L_1^2 + L_2^2 - 2L_1L_2cos(\pi-\theta_2)\tag{23}\]</span> 进而，解得 <span class="math display">\[cos\theta_2=\frac{x^2+y^2-L_1^2-L_2^2}{2L_1L_2}\\\theta_2 = \pm arccos(\frac{x^2+y^2-L_1^2-L_2^2}{2L_1L_2})\tag{24}\]</span> 由于<spanclass="math inline">\(\varphi\)</span>的限制，上式中<spanclass="math inline">\(\theta_2\)</span>应取正值。然后，可求出<spanclass="math inline">\(\theta_1\)</span>为：<spanclass="math inline">\(\theta_1 = \varphi - \theta_2\)</span>。</p><h2 id="matlab验证">MATLAB验证</h2><h3 id="验证正运动学">验证正运动学</h3><p>二连杆采用Modified DH创建的DH表如下：</p><table><thead><tr class="header"><th><span class="math inline">\(i\)</span></th><th><span class="math inline">\(\alpha_{i-1}\)</span></th><th><span class="math inline">\(a_{i-1}\)</span></th><th><span class="math inline">\(d_i\)</span></th><th><span class="math inline">\(\theta_{i}\)</span></th></tr></thead><tbody><tr class="odd"><td>1</td><td>0</td><td>0</td><td>0</td><td><span class="math inline">\(\theta_1=\pi/2\)</span></td></tr><tr class="even"><td>2</td><td>0</td><td><span class="math inline">\(L_1=5\)</span></td><td>0</td><td><span class="math inline">\(\theta_2 = -\pi/2\)</span></td></tr><tr class="odd"><td>3</td><td>0</td><td><span class="math inline">\(L_2=3\)</span></td><td>0</td><td>0</td></tr></tbody></table><p>利用Robotics SystemToolbox求解正运动学（这里作为标准答案检验我们的矩阵公式法求解的结果是否为真）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 使用的版本是matlab 2021b.</span><br><span class="hljs-comment">% 利用Robotics System Toolbox对平面二连杆进行正运动学计算.</span><br><span class="hljs-comment">% 利用改进D-H（MDH）法建立多轴机器人</span><br>clc;<br>clear;<br>L(<span class="hljs-number">1</span>)=Link(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;alpha&#x27;</span>, <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;offset&#x27;</span>,<span class="hljs-built_in">pi</span>/<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;modified&#x27;</span>);<br>L(<span class="hljs-number">2</span>)=Link(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;alpha&#x27;</span>, <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;offset&#x27;</span>,-<span class="hljs-built_in">pi</span>/<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;modified&#x27;</span>);<br>L(<span class="hljs-number">3</span>)=Link(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;alpha&#x27;</span>, <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;offset&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;modified&#x27;</span>);<br><br>robot = SerialLink( L,<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;平面二连杆&#x27;</span>) ; <br><br>robot.display();<span class="hljs-comment">% 展示出机器人的信息</span><br>view(<span class="hljs-number">3</span>)<br>teach(robot);<span class="hljs-comment">% 调出示教滑块</span><br><br></code></pre></td></tr></table></figure><figure><img src="利用Robotics%20System%20Toolbox的正运动学求解结果.png"alt="图10 利用Robotics System Toolbox的正运动学求解结果" /><figcaption aria-hidden="true">图10 利用Robotics SystemToolbox的正运动学求解结果</figcaption></figure><p>可以看到末端点的坐标为<span class="math inline">\([3, 5,0]\)</span>。</p><p>利用矩阵公式求解正运动学</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 用于生成一个变换矩阵.</span><br><span class="hljs-comment">% file: generate_T.m</span><br><span class="hljs-comment">% 函数名: generate_T.</span><br><span class="hljs-comment">% Args: </span><br><span class="hljs-comment">%   alpha, a, d, theta.</span><br><span class="hljs-comment">% Return:</span><br><span class="hljs-comment">%   T.</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">T</span> = <span class="hljs-title">generate_T</span><span class="hljs-params">(alpha, a, d, theta)</span></span><br><span class="hljs-comment">% 这里的T矩阵是式（3b）的矩阵</span><br>T = [<span class="hljs-built_in">cos</span>(theta) -<span class="hljs-built_in">sin</span>(theta) <span class="hljs-number">0</span> a;<br>         <span class="hljs-built_in">cos</span>(alpha)*<span class="hljs-built_in">sin</span>(theta) <span class="hljs-built_in">cos</span>(alpha)*<span class="hljs-built_in">cos</span>(theta) -<span class="hljs-built_in">sin</span>(alpha) -d*<span class="hljs-built_in">sin</span>(alpha);<br>         <span class="hljs-built_in">sin</span>(alpha)*<span class="hljs-built_in">sin</span>(theta) <span class="hljs-built_in">sin</span>(alpha)*<span class="hljs-built_in">cos</span>(theta) <span class="hljs-built_in">cos</span>(alpha) d*<span class="hljs-built_in">cos</span>(alpha);<br>         <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 使用的版本是matlab 2021b.</span><br><span class="hljs-comment">% file: forward_kinematics_formula.m</span><br><span class="hljs-comment">% 利用矩阵公式对平面二连杆进行正运动学计算.</span><br><span class="hljs-comment">% 利用改进D-H（MDH）法建立多轴机器人</span><br>T1 = generate_T(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">pi</span>/<span class="hljs-number">2</span>);<br>T2 = generate_T(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, -<span class="hljs-built_in">pi</span>/<span class="hljs-number">2</span>);<br>T3 = generate_T(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>P = T1*T2*T3<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs matlab">运行结果：<br>&gt;&gt; forward_kinematics_formula<br><br>P =<br><br>    <span class="hljs-number">1.0000</span>         <span class="hljs-number">0</span>         <span class="hljs-number">0</span>    <span class="hljs-number">3.0000</span><br>         <span class="hljs-number">0</span>    <span class="hljs-number">1.0000</span>         <span class="hljs-number">0</span>    <span class="hljs-number">5.0000</span><br>         <span class="hljs-number">0</span>         <span class="hljs-number">0</span>    <span class="hljs-number">1.0000</span>         <span class="hljs-number">0</span><br>         <span class="hljs-number">0</span>         <span class="hljs-number">0</span>         <span class="hljs-number">0</span>    <span class="hljs-number">1.0000</span><br></code></pre></td></tr></table></figure><p>可以看到末端点的坐标也为<span class="math inline">\([3, 5,0]\)</span>。</p><h3 id="验证逆运动学">验证逆运动学</h3><p>利用Robotics System Toolbox对平面二连杆进行逆运动学计算</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 使用的版本是matlab 2021b.</span><br><span class="hljs-comment">% file: inverse_kinematics_RT.m</span><br><span class="hljs-comment">% 利用Robotics System Toolbox对平面二连杆进行逆运动学计算.</span><br><span class="hljs-comment">% 利用改进D-H（MDH）法建立多轴机器人</span><br><span class="hljs-comment">% clc;</span><br>clear;<br>L(<span class="hljs-number">1</span>)=Link(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;alpha&#x27;</span>, <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;offset&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;modified&#x27;</span>);<br>L(<span class="hljs-number">2</span>)=Link(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;alpha&#x27;</span>, <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;offset&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;modified&#x27;</span>);<br>L(<span class="hljs-number">3</span>)=Link(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;alpha&#x27;</span>, <span class="hljs-number">0</span>,<span class="hljs-string">&#x27;offset&#x27;</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;modified&#x27;</span>);<br><br>robot = SerialLink( L,<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;平面二连杆&#x27;</span>) ; <br><br><span class="hljs-comment">%% 普通机器人的示教展示</span><br><span class="hljs-comment">% robot.display();% 展示出机器人的信息</span><br>view(<span class="hljs-number">3</span>)<br>teach(robot);<span class="hljs-comment">% 调出示教滑块</span><br><br><span class="hljs-comment">%% 机器人的正解函数</span><br><br>theta=[<span class="hljs-built_in">pi</span>/<span class="hljs-number">4</span>,-<span class="hljs-built_in">pi</span>/<span class="hljs-number">3</span>, <span class="hljs-number">0</span>];<br>robot.<span class="hljs-built_in">plot</span>(theta);<br>p=robot.fkine(theta)<br><br><span class="hljs-comment">%% 机器人的逆解</span><br>mask = [<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>];<br>q=ikine(robot,p,<span class="hljs-string">&#x27;mask&#x27;</span>,mask)<br>robot.<span class="hljs-built_in">plot</span>(q);<span class="hljs-comment">%输出机器人模型，后面的三个角为输出时的theta姿态</span><br><br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab">运行结果：<br>&gt;&gt; inverse_kinematics_RT<br> <br>p = <br>    <span class="hljs-number">0.9659</span>    <span class="hljs-number">0.2588</span>         <span class="hljs-number">0</span>     <span class="hljs-number">6.433</span><br>   <span class="hljs-number">-0.2588</span>    <span class="hljs-number">0.9659</span>         <span class="hljs-number">0</span>     <span class="hljs-number">2.759</span><br>         <span class="hljs-number">0</span>         <span class="hljs-number">0</span>         <span class="hljs-number">1</span>         <span class="hljs-number">0</span><br>         <span class="hljs-number">0</span>         <span class="hljs-number">0</span>         <span class="hljs-number">0</span>         <span class="hljs-number">1</span><br><br>q =<br><br>    <span class="hljs-number">0.0249</span>    <span class="hljs-number">1.0472</span>         <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>利用矩阵公式求解逆运动学</p>]]></content>
    
    
    <categories>
      
      <category>机器人</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前言</title>
    <link href="/2023/05/04/%E5%89%8D%E8%A8%80/"/>
    <url>/2023/05/04/%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>2022年初，我曾经搭建过一次个人博客，也陆续写了几篇博文，但最终没有坚持下去，因为总感觉自己写的技术文章是在抄文档，对自己的帮助也不是很大，而且我工作中的组长也一直给我灌输这种博文毫无意义的思想。</p><p>然而，由于近半年学的东西很杂，我发现很多知识没有得到系统地学习和进一步串联巩固，因此，还是想把写博客的习惯捡起来。于是，我在2023年5月4日第二次搭建了自己的博客。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
